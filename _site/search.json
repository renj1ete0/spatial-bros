[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Us",
    "section": "",
    "text": "The Spatial Bros consists of three members from the School of Computing and Information Systems at Singapore Management University who are taking the IS415 Geospatial Analytics and Applications course. View our profiles below!\n\n\n\n\nHello! My name is Harith and I am currently a Full-time student at Singapore Management University pursuing a double major degree in BSc (IS) Smart-City Management & Technology as my first major and Sustainability as my second major.\n‘If the hunger to learn is genuine, the appetite for growth is colossal’. With this line taken to heart, I am constantly looking for opportunities to learn and challenge myself to gain the most out of every obstacle I face.\nHarnessing the skillsets and experiences gained from working with and leading work teams in various sectors, I am committed to taking on increasing roles and responsibilities to ultimately embark on the goal of innovating and contributing to smart city solutions. Other than that, I enjoy playing pool and singing my heart out during my free time!\n\n\n\n\n\n\nCurrently a student pursuing a degree in Information System with track in Financial Technology. By aligning Technology with Finance is my interest and goal. It meets business needs, creates value and result in a more efficient eco-system.\nI am constantly looking forward to opportunities where I can try something new. This way I can acquire knowledge and explore new grounds where I believe there are endless findings. As such, I see myself as jack of all trades and master of absolute none.\nI am just an everyday student striving to live another day in this fast pace and ever changing society. Beyond that, I can be found on the streets running or cycling.\n\n\n\n\n\n\nI’m Ren Jie, a Year 2 Information Systems Undergraduate student at the Singapore Management University, majoring in Digitalisation & Cloud Solutions (SCIS) and Urban Science (CIS).\nMy interests are in urban science and urban planning. I am excited to learn more about geospatial analytics from this course which will value-add to my individualised second major in Urban Science at the College of Integrative Studies, where I aim to utilise, integrate and interpret data from the city into innovative solutions for cities of the future.\nI enjoy hiking and cycling during my free time, or enjoying the good food in Singapore!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial Bros",
    "section": "",
    "text": "The Spatial Bros is created to assist non-technical savvy users in performing geographical point pattern analysis. Our application will assist users with 2 kinds of analysis as shown:\nSpatial Points Analysis\n\nNetwork Constrained Spatial Point\n\nNetwork Constrained Kernel Density Map\nNetwork Constrained G/K Statistical Functions\n\n1st/2nd Order Spatial Point Pattern Analysis\n\nNetwork Constrained Kernel Density Map\nNetwork Constrained G/K Statistical Functions\n\n\nFor each of the analyses, the application will provide users with kernel density maps and perform types of hypothesis testing to allow users to generate insights towards statistical conclusions on the distribution of spatial points along networks.\nSome of the use cases could incldue\n…"
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Spatial Bros",
    "section": "Contents",
    "text": "Contents\n\nProject Proposal\nProject Poster\nInteractive Shiny Application\nPractice Research Paper"
  },
  {
    "objectID": "network_constraint_sp.html",
    "href": "network_constraint_sp.html",
    "title": "Project: Spatial Bros",
    "section": "",
    "text": "Network constrained Spatial Point Patterns Analysis (NetSPAA) is a collection of spatial point patterns analysis methods special developed for analysing spatial point event occurs on or alongside network.\nThe spatial point event can be locations of childcare centre for example.\nThe network, on the other hand can be a road network for example.\nMore information with regards to data sources used for this project can be found at the proposal\n\n\n\nIn this project, x packages will be used\n\npacman::p_load(sp, sf, rgdal, spNetwork, tmap, readr, dplyr, ggplot2)\n\n\n\n\n\n\nImporting of shapefile, converting to EPSG of 7855 and converting Geometry Type to LINGSTRING.\n\nroad_network <- st_read(\"data/geospatial/Roads Network\", layer = \"road-corridors\")\nroad_network <- st_transform(road_network, crs = 7855)\nroad_network_lines <- st_boundary(road_network) %>% \n                     st_cast(\"LINESTRING\")\n\n\n\n\n\npedestrian_network <- st_read(\"data/geospatial/Pedestrian Network/pedestrian-network.geojson\")\npedestrian_network <- st_transform(pedestrian_network, crs = 7855)\npedestrian_network <- pedestrian_network[st_geometry_type(st_geometry(pedestrian_network)) == \"LINESTRING\",]\n\n\n\n\n\ntram_network <- st_read(\"data/geospatial/Trams Network\", layer = \"PTV_METRO_TRAM_ROUTE\")\ntram_network <- st_transform(tram_network, crs = 7855)\n\n\n\n\nLocalities file downloaded was entire Australia. Therefore, we need to filter to retrieve localities of Melbourne.\n\nlocalities = st_read(\"data/geospatial/Localities\", layer = \"vic_localities\") \n#melbourne_localities <- localities[localities$UCL_NAME21 == \"Melbourne\", ]\n#melbourne_localities <- st_transform(melbourne_localities, crs = 7855)\n\n\n\n\nLocal Government Areas file downloaded was entire Australia. Therefore, we need to filter to retrieve Local Government Areas of Melbourne.\n\nlocal_government_areas = st_read(\"data/geospatial/Local Government Areas\", layer = \"LGA_2022_AUST_GDA2020\")\nmelbourne_local_government_areas = local_government_areas[local_government_areas$LGA_NAME22 == \"Melbourne\",]\nmelbourne_local_government_areas <- st_transform(melbourne_local_government_areas, crs = 7855)\n\n\n\n\nTo retrieve only latest as of 2021 business establishments and is not vacant.\n\nbusiness_est_sp <- st_read(\"data/geospatial/Business Establishments Spatial Point/business-establishments-with-address-and-industry-classification.geojson\") %>% filter(census_year == \"2021\") %>% filter(trading_name != \"Vacant\")\nbusiness_est_sp <- st_transform(business_est_sp, crs = 7855) \n\n\n\n\n\ndrinking_fountain_sp <- st_read(\"data/geospatial/Drinking Fountain Spatial Point\", layer = \"drinking-fountains\")\ndrinking_fountain_sp <- st_transform(drinking_fountain_sp, crs = 7855)\n\n\n\n\n\nlandmarks_sp <- st_read(\"data/geospatial/Landmarks Spatial Point\", layer = \"landmarks-and-places-of-interest-including-schools-theatres-health-services-spor\")\nlandmarks_sp <- st_transform(landmarks_sp, crs = 7855)\n\n\n\n\n\nchildcare_sp <- read_csv(\"data/geospatial/Childcare Centres Spatial Point/childcare-centres.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\nchildcare_sp_sf <- st_as_sf(childcare_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\n\n\n\n\n\nchildcare_spdf <- as(childcare_sp_sf, \"Spatial\")\nchildcare_spdf\n\n\n\n\n\n\npublic_toilets_sp <- read_csv(\"data/geospatial/Public Toilets Spatial Point/public-toilets.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\npublic_toilets_sp_sf <- st_as_sf(public_toilets_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\n\n\n\n\n\npublic_toilets_spdf <- as(public_toilets_sp_sf, \"Spatial\")\npublic_toilets_spdf\n\n\n\n\n\n\n\n\n\ntmap_options('view')\nroad_network_be <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(business_est_sp) +\n  tm_dots(size = 0.02, col=\"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_cc <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_df <- tm_shape(road_network_lines) +\n tm_lines() +\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_landmarks <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_pt <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\nSaving road networks with all spatial points to a html file separately\n\ntmap_save(road_network_cc, \"tmaphtml/road_network_cc.html\")\ntmap_save(road_network_be, \"tmaphtml/road_network_be.html\")\ntmap_save(road_network_df, \"tmaphtml/road_network_df.html\")\ntmap_save(road_network_landmarks, \"tmaphtml/road_network_landmarks.html\")\ntmap_save(road_network_pt, \"tmaphtml/road_network_pt.html\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_be <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(business_est_sp) +\n  tm_dots(size = 0.02, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_cc <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_df <- tm_shape(pedestrian_network) +\n tm_lines() +\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_landmarks <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_pt <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\nSaving pedestrian networks with all spatial points to a html file separately\n\ntmap_save(pedestrian_network_cc, \"tmaphtml/pedestrian_network_cc.html\")\ntmap_save(pedestrian_network_be, \"tmaphtml/pedestrian_network_be.html\")\ntmap_save(pedestrian_network_df, \"tmaphtml/pedestrian_network_df.html\")\ntmap_save(pedestrian_network_landmarks, \"tmaphtml/pedestrian_network_landmarks.html\")\ntmap_save(pedestrian_network_pt, \"tmaphtml/pedestrian_network_pt.html\")\n\n\n\n\n\ntmap_options('view')\ntram_network_be <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(business_est_sp) +\n  tm_dots(size = 0.02, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_cc <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_df <- tm_shape(tram_network) +\n tm_lines() +\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_landmarks <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_pt <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\nSaving tram networks with all spatial points to a html file separately\n\ntmap_save(tram_network_cc, \"tmaphtml/tram_network_cc.html\")\ntmap_save(tram_network_be, \"tmaphtml/tram_network_be.html\")\ntmap_save(tram_network_df, \"tmaphtml/tram_network_df.html\")\ntmap_save(tram_network_landmarks, \"tmaphtml/tram_network_landmarks.html\")\ntmap_save(tram_network_pt, \"tmaphtml/tram_network_pt.html\")\n\n\n\n\n\nIn this section, we will perform NetKDE analysis by using appropriate functions provided in spNetwork package.\n\n\nBefore computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with lixelize_lines() of spNetwork as shown in the code chunk below.\n\n# Lixels for Road Network\nroad_lixels_cc <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_be <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_df <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_lm <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_pt <- lixelize_lines(road_network_lines, 1000, mindist = 350)\n\n# Lixels for Pedestrian Network\npedestrian_lixels_cc <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_be <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_df <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_lm <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_pt <- lixelize_lines(pedestrian_network, 500, mindist = 250)\n\n# Lixels for Tram Network\ntram_lixels_cc <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_be <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_df <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_lm <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_pt <- lixelize_lines(tram_network, 1000, mindist = 350)\n\nThe length of a lixel, lx_length is set to 1000m, 500m and 1000m respectively for road_network, pedestrian_network and tram_network. The minimum length of a lixel, mindist is set to 350m for network of road and tram whereas 250m for pedestrian network.\n\n\n\nNext, lines_center() of spNetwork will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points as shown in the code chunk below.\n\n# Road network lines center\nroad_samples_cc <- lines_center(road_lixels_cc)\nroad_samples_be <- lines_center(road_lixels_be)\nroad_samples_df <- lines_center(road_lixels_df)\nroad_samples_lm <- lines_center(road_lixels_lm)\nroad_samples_pt <- lines_center(road_lixels_pt)\n\n# Pedestrian network lines center\npedestrian_samples_cc <- lines_center(pedestrian_lixels_cc)\npedestrian_samples_be <- lines_center(pedestrian_lixels_be)\npedestrian_samples_df <- lines_center(pedestrian_lixels_df)\npedestrian_samples_lm <- lines_center(pedestrian_lixels_lm)\npedestrian_samples_pt <- lines_center(pedestrian_lixels_pt)\n\n# # Tram network lines center\ntram_samples_cc <- lines_center(tram_lixels_cc)\ntram_samples_be <- lines_center(tram_lixels_be)\ntram_samples_df <- lines_center(tram_lixels_df)\ntram_samples_lm <- lines_center(tram_lixels_lm)\ntram_samples_pt <- lines_center(tram_lixels_pt)\n\n\n\n\nWe are ready to compute the NetKDE by using the code chunk below.\n\n\n\nroad_network_cc_densities <- nkde(road_network_lines, \n                  events = childcare_sp_sf,\n                  w = rep(1,nrow(childcare_sp_sf)),\n                  samples = road_samples_cc,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_be_densities <- nkde(road_network_lines, \n                  events = business_est_sp,\n                  w = rep(1,nrow(business_est_sp)),\n                  samples = road_samples_be,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_df_densities <- nkde(road_network_lines, \n                  events = drinking_fountain_sp,\n                  w = rep(1,nrow(drinking_fountain_sp)),\n                  samples = road_samples_df,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_lm_densities <- nkde(road_network_lines, \n                  events = landmarks_sp,\n                  w = rep(1,nrow(landmarks_sp)),\n                  samples = road_samples_lm,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_pt_densities <- nkde(road_network_lines, \n                  events = public_toilets_sp_sf,\n                  w = rep(1,nrow(public_toilets_sp_sf)),\n                  samples = road_samples_pt,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nBefore we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.\n\nroad_samples_cc$density <- road_network_cc_densities * 1000\nroad_lixels_cc$density <- road_network_cc_densities * 1000\n\nroad_samples_be$density <- road_network_be_densities * 1000\nroad_lixels_be$density <- road_network_be_densities * 1000\n\nroad_samples_df$density <- road_network_df_densities * 1000\nroad_lixels_df$density <- road_network_df_densities * 1000\n\nroad_samples_lm$density <- road_network_lm_densities * 1000\nroad_lixels_lm$density <- road_network_lm_densities * 1000\n\nroad_samples_pt$density <- road_network_pt_densities * 1000\nroad_lixels_pt$density <- road_network_pt_densities * 1000\n\n\n\n\ntmap_options('view')\nroad_networkKDE_cc <- tm_shape(road_lixels_cc) +\n  tm_lines(col=\"density\")+\n  tm_shape(childcare_spdf)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_be <- tm_shape(road_lixels_be) +\n  tm_lines(col=\"density\")+\n  tm_shape(business_est_sp)+\n  tm_dots(size = 0.02)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_df <- tm_shape(road_lixels_df) +\n  tm_lines(col=\"density\")+\n  tm_shape(drinking_fountain_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_lm <- tm_shape(road_lixels_lm) +\n  tm_lines(col=\"density\")+\n  tm_shape(landmarks_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_pt <- tm_shape(road_lixels_pt) +\n  tm_lines(col=\"density\")+\n  tm_shape(public_toilets_spdf)+\n  tm_dots(size = 0.03)\n\nSaving road networks KDE to separate html file\n\ntmap_save(road_networkKDE_cc, \"tmapnetworkKDEhtml/road_networkKDE_cc.html\")\ntmap_save(road_networkKDE_be, \"tmapnetworkKDEhtml/road_networkKDE_be.html\")\ntmap_save(road_networkKDE_df, \"tmapnetworkKDEhtml/road_networkKDE_df.html\")\ntmap_save(road_networkKDE_lm, \"tmapnetworkKDEhtml/road_networkKDE_lm.html\")\ntmap_save(road_networkKDE_pt, \"tmapnetworkKDEhtml/road_networkKDE_pt.html\")\n\n\n\n\n\nWe are ready to compute the NetKDE by using the code chunk below. When using the continuous and discontinuous methods, the calculation time and memory use can go wild if the network has many small edges (area with many of intersections and many events) - especially for pedestrian network. To avoid it, it is possible to set here a maximum depth. Considering that the kernel is divided at intersections, a value of max_depth value of 10 is set and should yield good estimates in most cases. (https://cran.r-project.org/web/packages/spNetwork/spNetwork.pdf)\n\n\n\npedestrian_network_cc_densities <- nkde(pedestrian_network, \n                  events = childcare_sp_sf,\n                  w = rep(1,nrow(childcare_sp_sf)),\n                  samples = pedestrian_samples_cc,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_be_densities <- nkde(pedestrian_network, \n                  events = business_est_sp,\n                  w = rep(1,nrow(business_est_sp)),\n                  samples = pedestrian_samples_be,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_df_densities <- nkde(pedestrian_network, \n                  events = drinking_fountain_sp,\n                  w = rep(1,nrow(drinking_fountain_sp)),\n                  samples = pedestrian_samples_df,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_lm_densities <- nkde(pedestrian_network, \n                  events = landmarks_sp,\n                  w = rep(1,nrow(landmarks_sp)),\n                  samples = pedestrian_samples_lm,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_pt_densities <- nkde(pedestrian_network, \n                  events = public_toilets_sp_sf,\n                  w = rep(1,nrow(public_toilets_sp_sf)),\n                  samples = pedestrian_samples_pt,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nBefore we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.\n\npedestrian_samples_cc$density <- pedestrian_network_cc_densities * 1000\npedestrian_lixels_cc$density <- pedestrian_network_cc_densities * 1000 \n\npedestrian_samples_be$density <- pedestrian_network_be_densities * 1000\npedestrian_lixels_be$density <- pedestrian_network_be_densities * 1000\n\npedestrian_samples_df$density <- pedestrian_network_df_densities * 1000\npedestrian_lixels_df$density <- pedestrian_network_df_densities * 1000\n\npedestrian_samples_lm$density <- pedestrian_network_lm_densities * 1000\npedestrian_lixels_lm$density <- pedestrian_network_lm_densities * 1000\n\npedestrian_samples_pt$density <- pedestrian_network_pt_densities * 1000\npedestrian_lixels_pt$density <- pedestrian_network_pt_densities * 1000\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_cc <- tm_shape(pedestrian_lixels_cc) +\n  tm_lines(col=\"density\")+\n  tm_shape(childcare_spdf)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_be <- tm_shape(pedestrian_lixels_be) +\n  tm_lines(col=\"density\")+\n  tm_shape(business_est_sp)+\n  tm_dots(size = 0.02)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_df <- tm_shape(pedestrian_lixels_df) +\n  tm_lines(col=\"density\")+\n  tm_shape(drinking_fountain_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_lm <- tm_shape(pedestrian_lixels_lm) +\n  tm_lines(col=\"density\")+\n  tm_shape(landmarks_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_pt <- tm_shape(pedestrian_lixels_pt) +\n  tm_lines(col=\"density\")+\n  tm_shape(public_toilets_spdf)+\n  tm_dots(size = 0.03)\n\nSaving road networks KDE to separate html file\n\ntmap_save(pedestrian_networkKDE_cc, \"tmapnetworkKDEhtml/pedestrian_networkKDE_cc.html\")\ntmap_save(pedestrian_networkKDE_be, \"tmapnetworkKDEhtml/pedestrian_networkKDE_be.html\")\ntmap_save(pedestrian_networkKDE_df, \"tmapnetworkKDEhtml/pedestrian_networkKDE_df.html\")\ntmap_save(pedestrian_networkKDE_lm, \"tmapnetworkKDEhtml/pedestrian_networkKDE_lm.html\")\ntmap_save(pedestrian_networkKDE_pt, \"tmapnetworkKDEhtml/pedestrian_networkKDE_pt.html\")\n\n\n\n\n\nWe are ready to compute the NetKDE by using the code chunk below.\n\n\n\ntram_network_cc_densities <- nkde(tram_network, \n                  events = childcare_sp_sf,\n                  w = rep(1,nrow(childcare_sp_sf)),\n                  samples = tram_samples_cc,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_be_densities <- nkde(tram_network, \n                  events = business_est_sp,\n                  w = rep(1,nrow(business_est_sp)),\n                  samples = tram_samples_be,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_df_densities <- nkde(tram_network, \n                  events = drinking_fountain_sp,\n                  w = rep(1,nrow(drinking_fountain_sp)),\n                  samples = tram_samples_df,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_lm_densities <- nkde(tram_network, \n                  events = landmarks_sp,\n                  w = rep(1,nrow(landmarks_sp)),\n                  samples = tram_samples_lm,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_pt_densities <- nkde(tram_network, \n                  events = public_toilets_sp_sf,\n                  w = rep(1,nrow(public_toilets_sp_sf)),\n                  samples = tram_samples_pt,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nBefore we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.\n\ntram_samples_cc$density <- tram_network_cc_densities * 1000\ntram_lixels_cc$density <- tram_network_cc_densities * 1000 \n\ntram_samples_be$density <- tram_network_be_densities * 1000\ntram_lixels_be$density <- tram_network_be_densities * 1000\n\ntram_samples_df$density <- tram_network_df_densities * 1000\ntram_lixels_df$density <- tram_network_df_densities * 1000\n\ntram_samples_lm$density <- tram_network_lm_densities * 1000\ntram_lixels_lm$density <- tram_network_lm_densities * 1000\n\ntram_samples_pt$density <- tram_network_pt_densities * 1000\ntram_lixels_pt$density <- tram_network_pt_densities * 1000\n\n\n\n\ntmap_options('view')\ntram_networkKDE_cc <- tm_shape(tram_lixels_cc) +\n  tm_lines(col=\"density\")+\n  tm_shape(childcare_spdf)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_be <- tm_shape(tram_lixels_be) +\n  tm_lines(col=\"density\")+\n  tm_shape(business_est_sp)+\n  tm_dots(size = 0.02)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_df <- tm_shape(tram_lixels_df) +\n  tm_lines(col=\"density\")+\n  tm_shape(drinking_fountain_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_lm <- tm_shape(tram_lixels_lm) +\n  tm_lines(col=\"density\")+\n  tm_shape(landmarks_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_pt <- tm_shape(tram_lixels_pt) +\n  tm_lines(col=\"density\")+\n  tm_shape(public_toilets_spdf)+\n  tm_dots(size = 0.03)\n\nSaving tram networks KDE to separate html file\n\ntmap_save(tram_networkKDE_cc, \"tmapnetworkKDEhtml/tram_networkKDE_cc.html\")\ntmap_save(tram_networkKDE_be, \"tmapnetworkKDEhtml/tram_networkKDE_be.html\")\ntmap_save(tram_networkKDE_df, \"tmapnetworkKDEhtml/tram_networkKDE_df.html\")\ntmap_save(tram_networkKDE_lm, \"tmapnetworkKDEhtml/tram_networkKDE_lm.html\")\ntmap_save(tram_networkKDE_pt, \"tmapnetworkKDEhtml/tram_networkKDE_pt.html\")\n\n\n\n\n\n\nIn this section, we are going to perform complete spatial randomness (CSR) test by using kfunctions() of spNetwork package. The null hypothesis is defined as:\n\n\nHo: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of business establishments) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of drinking fountain) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of landmarks) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of public toilets) are uniformly distributed over a pedestrian network in Melbourne City Area.\n\n\n\nHo: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of business establishments) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of drinking fountain) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of landmarks) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of public toilets) are uniformly distributed over a pedestrian network in Melbourne City Area.\n\n\n\nHo: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of business establishments) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of drinking fountain) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of landmarks) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of public toilets) are uniformly distributed over a tram network in Melbourne City Area.\nThe CSR test is based on the assumption of the binomial point process which implies the hypothesis that the spatial points are randomly and independently distributed over the various network.\nIf this hypothesis is rejected, we may infer that the distribution of spatial points are spatially interacting and dependent on each other; as a result, they may form nonrandom patterns.\n\n\n\n\n\n\nkfun_childcare_road <- kfunctions(road_network_lines, \n                             childcare_sp_sf,\n                             start = 0, \n                             end = 1000, \n                             step = 100, \n                             width = 50, \n                             nsim = 100, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n\n\nkfun_childcare_road <- kfun_childcare_road$plotk\n\n\n\n\n\nbusiness_est_sp_unique <- business_est_sp[!duplicated(st_geometry(business_est_sp)), ]\nkfun_be_road <- kfunctions(road_network_lines, \n                           business_est_sp_unique,\n                           start = 0, \n                           end = 1000, \n                           step = 100, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 100,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_be_road <- kfun_be_road$plotk\n\n\n\n\n\nkfun_df_road <- kfunctions(road_network_lines, \n                           drinking_fountain_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_df_road <- kfun_df_road$plotk\n\n\n\n\n\nkfun_lm_road <- kfunctions(road_network_lines, \n                           landmarks_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_lm_road <- kfun_lm_road$plotk\n\n\n\n\n\npublic_toilets_sp_sf_unique <- public_toilets_sp_sf[!duplicated(st_geometry(public_toilets_sp_sf)), ]\nkfun_pt_road <- kfunctions(road_network_lines, \n                           public_toilets_sp_sf,\n                           start = 0, \n                           end = 1000, \n                           step = 100, \n                           width = 50, \n                           nsim = 50,\n                           agg = 100,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_pt_road <- kfun_pt_road$plotk\n\n\nggsave(file = \"g&kplot/kfun_childcare_road.png\", plot = kfun_childcare_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_be_road.png\", plot = kfun_be_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_df_road.png\", plot = kfun_df_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_lm_road.png\", plot = kfun_lm_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_pt_road.png\", plot = kfun_pt_road, width = 6, height = 4, dpi = 300)\n\n\n\n\n\nkfun_childcare_pedestrian <- kfunctions(pedestrian_network, \n                             childcare_sp_sf,\n                             start = 0, \n                             end = 1000, \n                             step = 50, \n                             width = 50, \n                             nsim = 50, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n\n\nkfun_childcare_pedestrian <- kfun_childcare_pedestrian$plotk\n\n\n\n\n\nbusiness_est_sp_unique <- business_est_sp[!duplicated(st_geometry(business_est_sp)), ]\nkfun_be_pedestrian <- kfunctions(pedestrian_network, \n                           business_est_sp_unique,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 100,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_be_pedestrian <- kfun_be_pedestrian$plotk\n\n\n\n\n\nkfun_df_pedestrian <- kfunctions(pedestrian_network, \n                           drinking_fountain_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_df_pedestrian <- kfun_df_pedestrian$plotk\n\n\n\n\n\nkfun_lm_pedestrian <- kfunctions(pedestrian_network, \n                           landmarks_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_lm_pedestrian <- kfun_lm_pedestrian$plotk\n\n\n\n\n\npublic_toilets_sp_sf_unique <- public_toilets_sp_sf[!duplicated(st_geometry(public_toilets_sp_sf)), ]\nkfun_pt_pedestrian <- kfunctions(pedestrian_network, \n                           public_toilets_sp_sf,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50,\n                           agg = 100,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_pt_pedestrian <- kfun_pt_pedestrian$plotk\n\n\nggsave(file = \"g&kplot/kfun_childcare_pedestrian.png\", plot = kfun_childcare_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_be_pedestrian.png\", plot = kfun_be_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_df_pedestrian.png\", plot = kfun_df_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_lm_pedestrian.png\", plot = kfun_lm_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_pt_pedestrian.png\", plot = kfun_pt_pedestrian, width = 6, height = 4, dpi = 300)\n\n\n\n\n\nkfun_childcare_tram <- kfunctions(tram_network, \n                             childcare_sp_sf,\n                             start = 0, \n                             end = 500, \n                             step = 50, \n                             width = 50, \n                             nsim = 50, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n\n\nkfun_childcare_tram <- kfun_childcare_tram$plotk\n\n\n\n\n\nbusiness_est_sp_unique <- business_est_sp[!duplicated(st_geometry(business_est_sp)), ]\nkfun_be_tram <- kfunctions(tram_network, \n                           business_est_sp_unique,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 500,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_be_tram <- kfun_be_tram$plotk\n\n\n\n\n\nkfun_df_tram <- kfunctions(tram_network, \n                           drinking_fountain_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 500,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_df_tram <- kfun_df_tram$plotk\n\n\n\n\n\nkfun_lm_tram <- kfunctions(tram_network, \n                           landmarks_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 700,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_lm_tram <- kfun_lm_tram$plotk\n\n\n\n\n\npublic_toilets_sp_sf_unique <- public_toilets_sp_sf[!duplicated(st_geometry(public_toilets_sp_sf)), ]\nkfun_pt_tram <- kfunctions(tram_network, \n                           public_toilets_sp_sf,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50,\n                           agg = 500,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_pt_tram <- kfun_pt_tram$plotk\n\n\nggsave(file = \"g&kplot/kfun_childcare_tram.png\", plot = kfun_childcare_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_be_tram.png\", plot = kfun_be_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_df_tram.png\", plot = kfun_df_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_lm_tram.png\", plot = kfun_lm_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_pt_tram.png\", plot = kfun_pt_tram, width = 6, height = 4, dpi = 300)"
  },
  {
    "objectID": "nkde_consolidation.html",
    "href": "nkde_consolidation.html",
    "title": "NKDE_Consolidation",
    "section": "",
    "text": "Preparing the lixels objects\n\n#we let user_input_lx_length we set default 1000\n#we let user_input_mindist we set default 350 \nroad_lixels_cc <- lixelize_lines(network_name, user_input_lx_length, mindist = user_input_mindist)\n\n\n\nGenerating line centre points\n\nroad_samples_cc <- lines_center(road_lixels_cc)\n\n\n\nCompute NKDE\n\n#we let user input kernel_type default = \"quartic\"\n#we let user input method_type default = \"simple\"\nroad_network_cc_densities <- nkde(#network name, <- from RDS example road\n                  events = #spatial_point, <- from RDS example childcare\n                  w = rep(1,nrow(#spatial_point)), <- from RDS example childcare\n                  samples = #road_samples_cc, <- dependent on code line 16\n                  kernel_name = # \"kernel_type\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = #\"method_type\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\nRescaling Density Values\n\nroad_samples_cc$density <- road_network_cc_densities * 1000\nroad_lixels_cc$density <- road_network_cc_densities * 1000\n\n\n\nPlotting NKDE\n\ntmap_options('view')\nroad_networkKDE_cc <- tm_shape(#road_lixels_cc) + <- dependent on line 44\n  tm_lines(col=\"density\")+\n  tm_shape(#spatial_point)+ <- from RDS example childcare\n  tm_dots(size = 0.03) +\n    tm_shape(#melbourne_localities) + you may need to double check this from RDS and add above\n      tm_polygons() \ntmap_mode('plot')\n\n\n\nNetwork Constrained G- and K-Function Analysis\n\nkfun_childcare <- kfunctions(road_network_lines, \n           childcare_sp_sf,\n           start = 0, # user input\n           end = 1000, # user input \n           step = 100, \n           width = 50, \n           nsim = 100, # user input number of simulations\n           resolution = 50,\n           verbose = FALSE,\n           agg = 100, # user input let them pick 0 to 1000 \n           conf_int = 0.05)\n\nkfun_childcare$plotk"
  },
  {
    "objectID": "proposal.html#data-preparation",
    "href": "proposal.html#data-preparation",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.1 Data Preparation",
    "text": "5.1 Data Preparation\n\nTo source and assemble data from various sources out there\nImporting the Spatial Data (Geospatial)\nData Wrangling"
  },
  {
    "objectID": "proposal.html#exploratory-data-analysis",
    "href": "proposal.html#exploratory-data-analysis",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.2 Exploratory Data Analysis",
    "text": "5.2 Exploratory Data Analysis\n\nVisualise and examine the distribution of spatial pointers\nExamine any anomalies and outliers in the dataset sourced\nFurther Data Wrangling (where necessary)"
  },
  {
    "objectID": "proposal.html#network-constrained-point-pattern-analysis",
    "href": "proposal.html#network-constrained-point-pattern-analysis",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.3 Network Constrained Point Pattern Analysis",
    "text": "5.3 Network Constrained Point Pattern Analysis\n\nNetwork Kernel Density Estimation - To explore the intensity of points along network\nG and K function - To identify any potential clustering patterns, random distributions, even or uneven distributions of patterns"
  },
  {
    "objectID": "proposal.html#st-2nd-order-kernel-density-estimation",
    "href": "proposal.html#st-2nd-order-kernel-density-estimation",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.4 1st & 2nd Order Kernel Density Estimation",
    "text": "5.4 1st & 2nd Order Kernel Density Estimation\n\n1st order Kernel Density Estimation\nG and K function"
  },
  {
    "objectID": "proposal.html#network-constrained-and-category-based-point-pattern-analysis-for-suguo-retail-stores-in-nanjing-china",
    "href": "proposal.html#network-constrained-and-category-based-point-pattern-analysis-for-suguo-retail-stores-in-nanjing-china",
    "title": "Project Proposal: Spatial Bros",
    "section": "6.1 Network-constrained and category-based point pattern analysis for Suguo retail stores in Nanjing, China",
    "text": "6.1 Network-constrained and category-based point pattern analysis for Suguo retail stores in Nanjing, China\nhttps://www.tandfonline.com/doi/full/10.1080/13658816.2015.1080829\n\n6.1.1 Summary\nNetwork KDE and Network K-function was used to study retail service  hot-spot areas and spatial clustering patterns of a local retail giant, Suguo, in Nanjing City.\n\n\n6.1.2 Learning Points and Linking Back to Our Project\nThe bandwidth for generating network-constrained kernel density estimation (KDE) maps would produce representations of distributions that  and we should explore various network KDE bandwidths to find suitable bandwidth and also provide options for users to adjust bandwidth"
  },
  {
    "objectID": "proposal.html#ease-and-equity-of-point-of-interest-accessibility-via-public-transit-in-the-u.s",
    "href": "proposal.html#ease-and-equity-of-point-of-interest-accessibility-via-public-transit-in-the-u.s",
    "title": "Project Proposal: Spatial Bros",
    "section": "6.2 Ease and Equity of Point of Interest Accessibility via Public Transit in the U.S",
    "text": "6.2 Ease and Equity of Point of Interest Accessibility via Public Transit in the U.S\nhttps://arxiv.org/abs/2212.06954\n\n6.2.1 Summary\nThe team created a tool to analyse the ease and equity of access to major POI using public transit in US cities using an interactive website (to filter selected POIs) calculated with 2SFCA (2-step floating catchment area) approach.\n\nIt aims to explore effectiveness and equity of public transit system in major US cities\n\n\n6.2.2 Learning Points and Linking Back to Our Project\n\nUser Interface for users to filter by POI and view geographical accessibility information and additional"
  },
  {
    "objectID": "proposal.html#using-hexagonal-grids-and-network-analysis-for-spatial-accessibility-assessment-in-urban-environments-a-case-study-of-public-amenities-in-toruń",
    "href": "proposal.html#using-hexagonal-grids-and-network-analysis-for-spatial-accessibility-assessment-in-urban-environments-a-case-study-of-public-amenities-in-toruń",
    "title": "Project Proposal: Spatial Bros",
    "section": "6.3 Using hexagonal grids and network analysis for spatial accessibility assessment in urban environments – a case study of public amenities in Toruń",
    "text": "6.3 Using hexagonal grids and network analysis for spatial accessibility assessment in urban environments – a case study of public amenities in Toruń\nhttp://dx.doi.org/10.2478/mgrsd-2018-0037\n\n6.3.1 Summary\nThe paper looks at a methodology to analyse spatial accessibility using network analysis and a hexagonal grid to the city of Toruń, Poland. The paper also explored that it is important to empower citizens with knowledge of the geospatial analysis and created a web application to empower citizens with knowledge.\n\n\n6.3.2 Learning Points and Linking Back to Our Project\n\nAdopt a similar methodology of converting distance for OD Matrix, specifically Origin and Destination distances to travel times by assuming a walking speed of 4km/h\nNetwork will be calculated using the travel time of the appropriate speed (eg. road will be calculated based on road speed limit)\nThis will prevent underestimation of travel times which may affect the accessbility metrics"
  },
  {
    "objectID": "proposal.html#home-page",
    "href": "proposal.html#home-page",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.1 Home Page",
    "text": "7.1 Home Page"
  },
  {
    "objectID": "proposal.html#network-kde",
    "href": "proposal.html#network-kde",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.2 Network KDE",
    "text": "7.2 Network KDE"
  },
  {
    "objectID": "proposal.html#network-statistical-function",
    "href": "proposal.html#network-statistical-function",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.3 Network Statistical Function",
    "text": "7.3 Network Statistical Function"
  },
  {
    "objectID": "proposal.html#st-order-kde",
    "href": "proposal.html#st-order-kde",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.4 1st Order KDE",
    "text": "7.4 1st Order KDE"
  },
  {
    "objectID": "proposal.html#st-order-stat-function",
    "href": "proposal.html#st-order-stat-function",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.5 1st Order Stat Function",
    "text": "7.5 1st Order Stat Function"
  },
  {
    "objectID": "proposal.html#nd-order-kde",
    "href": "proposal.html#nd-order-kde",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.6 2nd Order KDE",
    "text": "7.6 2nd Order KDE"
  },
  {
    "objectID": "proposal.html#nd-order-stat-function",
    "href": "proposal.html#nd-order-stat-function",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.7 2nd Order Stat Function",
    "text": "7.7 2nd Order Stat Function"
  },
  {
    "objectID": "proposal.html#data",
    "href": "proposal.html#data",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.8 Data",
    "text": "7.8 Data"
  },
  {
    "objectID": "sp.html",
    "href": "sp.html",
    "title": "Project: Spatial Bros",
    "section": "",
    "text": "Spatial Point Patterns Analysis.\nThe spatial point event can be locations of childcare centre for example.\nMore information with regards to data sources used for this project can be found at the proposal\n\n\n\nIn this project, x packages will be used\n\npacman::p_load(sp, sf, rgdal, spNetwork, tmap, readr, dplyr, ggplot2, spatstat, maptools)\n\n\n\n\n\n\nLocalities file downloaded was entire Australia. Therefore, we need to filter to retrieve localities of Melbourne.\n\nlocalities = st_read(\"data/geospatial/Localities\", layer = \"vic_localities\") \n#melbourne_localities <- localities[localities$UCL_NAME21 == \"Melbourne\", ]\n#melbourne_localities <- st_transform(melbourne_localities, crs = 7855)\n\n\n\n\nLocal Government Areas file downloaded was entire Australia. Therefore, we need to filter to retrieve Local Government Areas of Melbourne.\n\nlocal_government_areas = st_read(\"data/geospatial/Local Government Areas\", layer = \"LGA_2022_AUST_GDA2020\")\nmelbourne_local_government_areas = local_government_areas[local_government_areas$LGA_NAME22 == \"Melbourne\",]\nmelbourne_local_government_areas <- st_transform(melbourne_local_government_areas, crs = 7855)\n\n\n\n\nTo retrieve only latest as of 2021 business establishments and is not vacant.\n\nbusiness_est_sp <- st_read(\"data/geospatial/Business Establishments Spatial Point/business-establishments-with-address-and-industry-classification.geojson\") %>% filter(census_year == \"2021\") %>% filter(trading_name != \"Vacant\")\nbusiness_est_sp <- st_transform(business_est_sp, crs = 7855) \n\n\n\n\n\ndrinking_fountain_sp <- st_read(\"data/geospatial/Drinking Fountain Spatial Point\", layer = \"drinking-fountains\")\ndrinking_fountain_sp <- st_transform(drinking_fountain_sp, crs = 7855)\n\n\n\n\n\nlandmarks_sp <- st_read(\"data/geospatial/Landmarks Spatial Point\", layer = \"landmarks-and-places-of-interest-including-schools-theatres-health-services-spor\")\nlandmarks_sp <- st_transform(landmarks_sp, crs = 7855)\n\n\n\n\n\nchildcare_sp <- read_csv(\"data/geospatial/Childcare Centres Spatial Point/childcare-centres.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\nchildcare_sp_sf <- st_as_sf(childcare_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\n\n\n\n\n\nchildcare_spdf <- as(childcare_sp_sf, \"Spatial\")\nchildcare_spdf\n\n\n\n\n\n\npublic_toilets_sp <- read_csv(\"data/geospatial/Public Toilets Spatial Point/public-toilets.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\npublic_toilets_sp_sf <- st_as_sf(public_toilets_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\n\n\n\n\n\npublic_toilets_spdf <- as(public_toilets_sp_sf, \"Spatial\")\npublic_toilets_spdf\n\n\n\n\n\n\n\n\n\ntmap_mode(\"view\")\n  tm_shape(business_est_sp) +\n  tm_dots(\"industry_anzsic4_description\", size = 0.02, popup.vars = c(\"industry_anzsic4_description\" = \"industry_anzsic4_description\"))\n\n\n\n\n\ntmap_mode(\"view\")\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_mode('view')\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_mode('view')\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_mode('view')\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\nUsing spatstat, we will\n\n\n\nbusiness_est_gsp <- as_Spatial(business_est_sp)\nchildcare_gsp <- as_Spatial(childcare_sp_sf)\ndrinking_fountain_gsp <- as_Spatial(drinking_fountain_sp)\nlandmarks_gsp <- as_Spatial(landmarks_sp)\npublic_toilets_gsp <- as_Spatial(public_toilets_sp_sf)\n\n\n\n\n\nbusiness_est_spc <- as(business_est_gsp, \"SpatialPoints\")\nchildcare_spc <- as(childcare_gsp, \"SpatialPoints\")\ndrinking_fountain_spc <- as(drinking_fountain_gsp, \"SpatialPoints\")\nlandmarks_spc <- as(landmarks_gsp, \"SpatialPoints\")\npublic_toilets_spc <- as(public_toilets_gsp, \"SpatialPoints\")\n\n\n\n\n\nbusiness_est_ppp <- as.ppp(business_est_spc)\nchildcare_ppp <- as.ppp(childcare_spc)\ndrinking_fountain_ppp <- as.ppp(drinking_fountain_spc)\nlandmarks_ppp <- as.ppp(landmarks_spc)\npublic_toilets_ppp <- as.ppp(public_toilets_spc)\n\n\n\n\n\nany(duplicated(business_est_ppp))\nany(duplicated(childcare_ppp))\nany(duplicated(drinking_fountain_ppp))\nany(duplicated(landmarks_ppp))\nany(duplicated(public_toilets_ppp))\n\n\n\n\n\nmultiplicity(business_est_ppp)\nsum(multiplicity(business_est_ppp) > 1)\n\nHandling duplicated events using jitter to slightly offset them\n\nbusiness_est_ppp_jit <- rjitter(business_est_ppp,\n                             retry = TRUE,\n                             nsim = 1,\n                             drop = TRUE)\n\nany(duplicated(business_est_ppp_jit))\n\n\n\n\n\nmelbourne_lga_spat <- as_Spatial(melbourne_local_government_areas)\nmelbourne_lga_sp <- as(melbourne_lga_spat, \"SpatialPolygons\")\nmelbourne_lga_owin <- as(melbourne_lga_sp, \"owin\")\n\n\nplot(melbourne_lga_owin)\n\nsummary(melbourne_lga_owin)\n\n\n\n\n\nbusiness_est_jit_melb_ppp = business_est_ppp_jit[melbourne_lga_owin]\nchildcare_melb_ppp = childcare_ppp[melbourne_lga_owin]\ndrinking_fountai_melb_ppp = drinking_fountain_ppp[melbourne_lga_owin]\nlandmarks_melb_ppp = landmarks_ppp[melbourne_lga_owin]\npublic_toilets_melb_ppp = public_toilets_ppp[melbourne_lga_owin]\n\n\nsummary(business_est_jit_melb_ppp)\nsummary(childcare_melb_ppp)\nsummary(drinking_fountai_melb_ppp)\nsummary(landmarks_melb_ppp)\nsummary(public_toilets_melb_ppp)\n\n\nplot(business_est_jit_melb_ppp)\nplot(childcare_melb_ppp)\nplot(drinking_fountai_melb_ppp)\nplot(landmarks_melb_ppp)\nplot(public_toilets_melb_ppp)\n\n\n\n\n\nbusiness_est_jit_melb_ppp.km <- rescale(business_est_jit_melb_ppp, 1000, \"km\")\nchildcare_melb_ppp.km <- rescale(childcare_melb_ppp, 1000, \"km\")\ndrinking_fountai_melb_ppp.km <- rescale(drinking_fountai_melb_ppp, 1000, \"km\")\nlandmarks_melb_ppp.km <- rescale(landmarks_melb_ppp, 1000, \"km\")\npublic_toilets_melb_ppp.km <- rescale(public_toilets_melb_ppp, 1000, \"km\")\n\n\n\n\n\npar(mfrow=c(2,2))\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"gaussian\"), \n             main = \"Gaussian\")\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"epanechnikov\"), \n             main = \"Epanechnikov\")\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"quartic\"), \n             main = \"Quartic\")\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"disc\"), \n             main = \"Disc\")\n\n\n\n\n\nkde_businessMB_adaptive <- adaptive.density(business_est_jit_melb_ppp.km, method = \"kernel\")\nplot(kde_businessMB_adaptive)\n\n\nkde_childcareMB_adaptive <- adaptive.density(childcare_melb_ppp.km, method = \"kernel\")\nplot(kde_childcareMB_adaptive)\n\n\nkde_drinkMB_adaptive <- adaptive.density(drinking_fountai_melb_ppp.km, method = \"kernel\")\nplot(kde_drinkMB_adaptive)\n\n\nkde_landmMB_adaptive <- adaptive.density(landmarks_melb_ppp.km, method = \"kernel\")\nplot(kde_landmMB_adaptive)\n\n\nkde_pubtoilet_adaptive <- adaptive.density(public_toilets_melb_ppp.km, method = \"kernel\")\nplot(kde_pubtoilet_adaptive)\n\n\n  kde.grid <- as.SpatialGridDataFrame.im(kde_pubtoilet_adaptive)\n  kde_raster <- raster(kde.grid)\nkde.grid <- CRS(SRS_string = \"EPSG:7855\")\ntm_shape(kde_raster) +\n  tm_raster(\"v\")\n\n\nkde.grid"
  },
  {
    "objectID": "SpatialBros/UntitledQMD.html",
    "href": "SpatialBros/UntitledQMD.html",
    "title": "",
    "section": "",
    "text": "install.packages(\"sf_1.0-9.tar.gz\", repos = NULL, type=\"source\")\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(sp)\nlibrary(sf)\nlibrary(rgdal)\nlibrary(spNetwork)\nlibrary(tmap)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n\nloc <- read_rds(\"rds/melbourne_localities.rds\")\n\n\nloc <- st_transform(loc, crs = 7855)\n\n\nplot(loc)\n\n\nboundary <- read_rds(\"rds/melbourne_local_government_areas.rds\")\n\n\nboundary <- st_transform(boundary, crs = 7855)\n\n\nlocalities = st_read(\"test/\", layer = \"vic_localities\") \n\n\nlocalities <- st_transform(localities, crs = 7855)\n\n\ntest <- localities %>% filter(LOC_NAME %in% c(\"Carlton\", \"Carlton North\", \"Docklands\", \"East Melbourne\", \"Flemington\", \"Kensington\", \"Melbourne\", \"North Melbourne\", \"Parkville\", \"Port Melbourne\", \"South Wharf\", \"South Yarra\", \"Southbank\", \"West Melbourne\"))\n\n\nplot(test)\nplot(boundary)\n\n\nsaveRDS(test, \"rds/melbourne_localities.rds\")\n\n\ntest3\nboundary\n\n\ntest3 <- localities %>% filter(LOC_NAME == \"Flemington\")\n\ntest2 <- st_intersection(boundary, test)\n\n\nplot(test2)\n\n\nsaveRDS(test2, \"rds/melbourne_localities.rds\")\n\n\nnet_lines <- read_rds(\"rds/road_network_lines.rds\")\nnet_lines\n\n\nhi <- st_intersection(net_lines, boundary)\n\n\nloc_interest = read_rds(\"rds/drinking_fountain.rds\")\nnetwork_type = read_rds(\"rds/road_network_lines.rds\")\n\n      adaptive = FALSE\n      trim_bw = NULL\n\n    \n    cv_scores <- bw_cv_likelihood_calc(c(200,800),50,\n                             network_type, loc_interest,\n                             rep(1,nrow(loc_interest)),\n                             \"quartic\", \"simple\" , verbose=FALSE, check=TRUE)\n    max_index <- which.max(cv_scores[,2])\n    max_bandwidth <- cv_scores[max_index, 1]\n\n    road_lixels_cc <- lixelize_lines(network_type, 700, mindist = 350)\n    road_samples_cc <- lines_center(road_lixels_cc)\n    road_network_cc_densities <- nkde(network_type,\n                                      events = loc_interest,\n                                      w = rep(1,nrow(loc_interest)), \n                                      samples = road_samples_cc, \n                                      kernel_name =  noquote(input$kernel_name),\n                                      bw = max_bandwidth, \n                                      trim_bw = trim_bw,\n                                      div= \"bw\", \n                                      adaptive = adaptive,\n                                      method = noquote(input$method_name), \n                                      digits = 3, \n                                      tol = 1,\n                                      grid_shape = c(1,1), \n                                      max_depth = 8,\n                                      agg = 10,\n                                      sparse = TRUE,\n                                      verbose = FALSE)\n    road_samples_cc$density <- road_network_cc_densities * 1000\n    road_lixels_cc$density <- road_network_cc_densities * 1000\n    \n    tmap_options(\"view\")\n          tm_shape(localities) +\n        tm_polygons(\"LOC_NAME\", alpha=0.1) +\n        tm_shape(boundary) +\n        tm_borders(lwd = 2.5, lty = 5,  col=\"blue\") +\n        tm_shape(road_lixels_cc) +\n        tm_lines(lwd = 1.5, col = \"density\")+\n        tm_shape(loc_interest)+ \n        tm_dots(size = 0.03, alpha = 0.6)"
  }
]