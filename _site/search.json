[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About Us",
    "section": "",
    "text": "The Spatial Bros consists of three members from the School of Computing and Information Systems at Singapore Management University who are taking the IS415 Geospatial Analytics and Applications course. View our profiles below!\n\n\n\n\nHello! My name is Harith and I am currently a Full-time student at Singapore Management University pursuing a double major degree in BSc (IS) Smart-City Management & Technology as my first major and Sustainability as my second major.\n‘If the hunger to learn is genuine, the appetite for growth is colossal’. With this line taken to heart, I am constantly looking for opportunities to learn and challenge myself to gain the most out of every obstacle I face.\nHarnessing the skillsets and experiences gained from working with and leading work teams in various sectors, I am committed to taking on increasing roles and responsibilities to ultimately embark on the goal of innovating and contributing to smart city solutions. Other than that, I enjoy playing pool and singing my heart out during my free time!\n\nLinkedIn\n\n\n\n\n\nCurrently a student pursuing a degree in Information System with track in Financial Technology. By aligning Technology with Finance is my interest and goal. It meets business needs, creates value and result in a more efficient eco-system.\nI am constantly looking forward to opportunities where I can try something new. This way I can acquire knowledge and explore new grounds where I believe there are endless findings. As such, I see myself as jack of all trades and master of absolute none.\nI am just an everyday student striving to live another day in this fast pace and ever changing society. Beyond that, I can be found on the streets running or cycling.\n\nLinkedIn\n\n\n\n\n\nI’m Ren Jie, a Year 2 Information Systems Undergraduate student at the Singapore Management University, majoring in Digitalisation & Cloud Solutions (SCIS) and Urban Science (CIS).\nMy interests are in urban science and urban planning. I am excited to learn more about geospatial analytics from this course which will value-add to my individualised second major in Urban Science at the College of Integrative Studies, where I aim to utilise, integrate and interpret data from the city into innovative solutions for cities of the future.\nI enjoy hiking and cycling during my free time, or enjoying the good food in Singapore!\n\nLinkedIn"
  },
  {
    "objectID": "data.html",
    "href": "data.html",
    "title": "Data Pre-processing",
    "section": "",
    "text": "This page contains steps to replicate the pre-processed datasets used on the Shiny Web Application. They are pre-processed ahead of time to prevent reprocessing on each load, which lengthens and complicates the process of loading the Shiny Web Application for each session."
  },
  {
    "objectID": "data.html#brief-overview-of-steps",
    "href": "data.html#brief-overview-of-steps",
    "title": "Data Pre-processing",
    "section": "2 Brief Overview of Steps",
    "text": "2 Brief Overview of Steps\nDatasets are converted to sf Dataframes and stored as RDS with its corresponding Projected Coordinate System (EPSG:7855 of GDA2020 Zone 55).\nGDA2020 datasets were obtained from the relavant sources.\nFurther processing to ppp or spatial* formats are done within R, since 1st, 2nd Order Spatial Point Pattern Analysis and Network Constrained Spatial Point Pattern Analysis requires different formats. These helps to reduce the number of dataset formats we need to store in RDS."
  },
  {
    "objectID": "data.html#datasets-used",
    "href": "data.html#datasets-used",
    "title": "Data Pre-processing",
    "section": "3 Datasets Used",
    "text": "3 Datasets Used\nThe datasets used are documented in the Project Proposal and can be obtained from Australia Bureau of Statistics, City of Melbourne Open Data and Data Vic (State Government of Victoria).\nCode to manipulate the data are listed below:"
  },
  {
    "objectID": "data.html#installing-the-r-packages",
    "href": "data.html#installing-the-r-packages",
    "title": "Data Pre-processing",
    "section": "4 Installing the R packages",
    "text": "4 Installing the R packages\nIn this project, x packages will be used\n\npacman::p_load(sp, sf, rgdal, spNetwork, tmap, readr, dplyr, ggplot2)"
  },
  {
    "objectID": "data.html#data-import-and-preparation",
    "href": "data.html#data-import-and-preparation",
    "title": "Data Pre-processing",
    "section": "5 Data Import and Preparation",
    "text": "5 Data Import and Preparation\n\n5.1 Melbourne City’s Road Network\nImporting of shapefile, converting to EPSG of 7855 and converting Geometry Type to LINGSTRING.\n\nroad_network <- st_read(\"data/geospatial/Roads Network\", layer = \"road-corridors\")\nroad_network <- st_transform(road_network, crs = 7855)\nroad_network_lines <- st_boundary(road_network) %>% \n                     st_cast(\"LINESTRING\")\nwrite_rds(road_network_lines, \"SpatialBros/rds/road_network_lines.rds\")\n\n\n\n5.2 Melbourne City’s Pedestrian Network\n\npedestrian_network <- st_read(\"data/geospatial/Pedestrian Network/pedestrian-network.geojson\")\npedestrian_network <- st_transform(pedestrian_network, crs = 7855)\npedestrian_network <- pedestrian_network[st_geometry_type(st_geometry(pedestrian_network)) == \"LINESTRING\",]\nwrite_rds(pedestrian_network, \"SpatialBros/rds/pedestrian_network_lines.rds\")\n\n\n\n5.3 Melbourne City’s Tram Network\n\ntram_network <- st_read(\"data/geospatial/Trams Network\", layer = \"PTV_METRO_TRAM_ROUTE\")\ntram_network <- st_transform(tram_network, crs = 7855)\nwrite_rds(tram_network, \"SpatialBros/rds/tram_network_lines.rds\")\n\n\n\n5.4 Melbourne City’s Local Government Areas\nLocal Government Areas file downloaded was entire Australia. Therefore, we need to filter to retrieve Local Government Areas of Melbourne.\n\nlocal_government_areas = st_read(\"data/geospatial/Local Government Areas\", layer = \"LGA_2022_AUST_GDA2020\")\nmelbourne_local_government_areas = local_government_areas[local_government_areas$LGA_NAME22 == \"Melbourne\",]\nmelbourne_local_government_areas <- st_transform(melbourne_local_government_areas, crs = 7855)\nwrite_rds(melbourne_local_government_areas, \"SpatialBros/rds/melbourne_local_government_areas.rds\")\n\n\n\n5.5 Melbourne City’s Local Government Areas\nLocal Government Areas file downloaded was entire Australia. Therefore, we need to filter to retrieve Local Government Areas of Melbourne.\n\nlocal_government_areas = st_read(\"data/geospatial/Local Government Areas\", layer = \"LGA_2022_AUST_GDA2020\")\nmelbourne_local_government_areas = local_government_areas[local_government_areas$LGA_NAME22 == \"Melbourne\",]\nmelbourne_local_government_areas <- st_transform(melbourne_local_government_areas, crs = 7855)\nwrite_rds(melbourne_local_government_areas, \"SpatialBros/rds/melbourne_local_government_areas.rds\")\n\n\n\n5.6 Localities\nLocalities file downloaded was entire Australia. Therefore, we need to filter to retrieve localities of Melbourne.\n\nlocalities = st_read(\"data/geospatial/Localities\", layer = \"UCL_2021_AUST_GDA2020\") \nmelbourne_localities <- localities[localities$UCL_NAME21 == \"Melbourne\", ]\nmelbourne_localities <- st_transform(melbourne_localities, crs = 7855)\n\nNext, since some LGA’s may exceed the city limits of the City of Melbourne, we want to reduce the region of these LGA’s to fit City of Melbourne’s city limits to be able to perform our analysis as the datasets only provides data within City of Melbourne city limits.\n\nmelbourne_localities_filtered <- st_intersection(local_government_areas, melbourne_localities)\nwrite_rds(melbourne_localities_filtered, \"SpatialBros/rds/melbourne_localities.rds\")\n\n\n\n5.7 Melbourne City’s Business Establishments Spatial Point\nTo retrieve only latest as of 2021 business establishments.\n\nbusiness_est_sp <- st_read(\"data/geospatial/Business Establishments Spatial Point/business-establishments-with-address-and-industry-classification.geojson\") %>% filter(census_year == \"2021\")\nbusiness_est_sp <- st_transform(business_est_sp, crs = 7855)\nwrite_rds(business_est_sp, \"SpatialBros/rds/business_establishments.rds\")\n\n\n\n5.8 Melbourne City’s Drinking Fountain Spatial Point\n\ndrinking_fountain_sp <- st_read(\"data/geospatial/Drinking Fountain Spatial Point\", layer = \"drinking-fountains\")\ndrinking_fountain_sp <- st_transform(drinking_fountain_sp, crs = 7855)\nwrite_rds(drinking_fountain_sp, \"SpatialBros/rds/drinking_fountain.rds\")\n\n\n\n5.9 Melbourne City’s Landmarks Spatial Point\n\nlandmarks_sp <- st_read(\"data/geospatial/Landmarks Spatial Point\", layer = \"landmarks-and-places-of-interest-including-schools-theatres-health-services-spor\")\nlandmarks_sp <- st_transform(landmarks_sp, crs = 7855)\nwrite_rds(landmarks_sp, \"SpatialBros/rds/landmarks.rds\")\n\n\n\n5.10 Melbourne City’s Childcare Centres Spatial Point\n\nchildcare_sp <- read_csv(\"data/geospatial/Childcare Centres Spatial Point/childcare-centres.csv\")\n\n\n5.10.1 Creating a simple feature data frame from Childcare Centres Spatial Point listings\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\nchildcare_sp_sf <- st_as_sf(childcare_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\nwrite_rds(childcare_sp_sf, \"SpatialBros/rds/childcare.rds\")\n\n\n\n\n5.11 Melbourne City’s Public Toilets Spatial Point\n\npublic_toilets_sp <- read_csv(\"data/geospatial/Public Toilets Spatial Point/public-toilets.csv\")\n\n\n5.11.1 Creating a simple feature data frame from Public Toilets Spatial Point listings\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\npublic_toilets_sp_sf <- st_as_sf(public_toilets_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\nwrite_rds(public_toilets_sp_sf, \"SpatialBros/rds/public_toilets.rds\")"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spatial Bros",
    "section": "",
    "text": "Note\n\n\n\nNote: The Spatial Bros shiny web application may take up to 3 minutes to load fully, please wait patiently, thank you."
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "Spatial Bros",
    "section": "Background",
    "text": "Background\n\n\n\n\n\nThe City of Melbourne has many datasets that are readily available to the public, through City of Melbourne Open Data and Data Vic. Yet, this only fufills the first part of ‘data access’ by providing datasets on their websites available for download and simple spatial points exploration using the interactive map provided.\nUsers who are not trained in geospatial analysis or GIS are unable to perform their own analysis to understand spatial pattern or trends behind their neighbourhood which could help citizens or outsiders to understand the city better and possibly formulate citizen efforts.\nThese are important pointers as the true democratisation of data should allow users to be empowered with tools to comfortably analyse datasets with ease and come up with their analysis and conclusions."
  },
  {
    "objectID": "index.html#about-the-project",
    "href": "index.html#about-the-project",
    "title": "Spatial Bros",
    "section": "About the Project",
    "text": "About the Project\n\nNetwork Constrained Spatial Point Pattern Analysis of Accomodation in City of Melbourne by Road Network\nThe Spatial Bros is created to fufill the next step of data democratisation to assist non-technical savvy users in performing geographical point pattern analysis to gain insights from open data. Our application will assist users with 2 kinds of analysis as shown:\nSpatial Points Analysis\n\nNetwork Constrained Spatial Point\n\nNetwork Constrained Kernel Density Map\nNetwork Constrained G/K Statistical Functions\n\n1st/2nd Order Spatial Point Pattern Analysis\n\nKernel Density Map\n1st Order Clarks and Evans Test\n2nd Order G/K Statistical Functions\n\n\nFor each of the analyses, the application will provide users with kernel density maps and perform types of hypothesis testing to allow users to generate insights towards statistical conclusions on the distribution of spatial points along networks.\nUsers can look forward to a simple-to-use interface, with clear instructions to understand the functionality of each feature, explanations of each option and instructions on interpreting the output data to come up with their conclusions."
  },
  {
    "objectID": "index.html#fun-areas-to-explore",
    "href": "index.html#fun-areas-to-explore",
    "title": "Spatial Bros",
    "section": "Fun Areas to Explore",
    "text": "Fun Areas to Explore\nHere are some locations of interest you can explore and analyse to get started!\n\nDrinking Fountains\nBusiness Establishments > Vacant Space\nPublic Toilets\nBusiness Establishments > Accomodation\nBusiness Establishments > Convenience Store"
  },
  {
    "objectID": "index.html#contents",
    "href": "index.html#contents",
    "title": "Spatial Bros",
    "section": "Contents",
    "text": "Contents\n\nProject Proposal\nProject Poster\nInteractive Shiny Application\nPractice Research Paper\nUser Guide"
  },
  {
    "objectID": "index.html#special-thanks",
    "href": "index.html#special-thanks",
    "title": "Spatial Bros",
    "section": "Special Thanks",
    "text": "Special Thanks\nThis project is done for IS415 Geospatial Analytics & Application under the guidance of Professor Kam Tin Seong."
  },
  {
    "objectID": "proposal.html#data-preparation",
    "href": "proposal.html#data-preparation",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.1 Data Preparation",
    "text": "5.1 Data Preparation\n\nTo source and assemble data from various sources out there\nImporting the Spatial Data (Geospatial)\nData Wrangling"
  },
  {
    "objectID": "proposal.html#exploratory-data-analysis",
    "href": "proposal.html#exploratory-data-analysis",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.2 Exploratory Data Analysis",
    "text": "5.2 Exploratory Data Analysis\n\nVisualise and examine the distribution of spatial pointers\nExamine any anomalies and outliers in the dataset sourced\nFurther Data Wrangling (where necessary)"
  },
  {
    "objectID": "proposal.html#network-constrained-point-pattern-analysis",
    "href": "proposal.html#network-constrained-point-pattern-analysis",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.3 Network Constrained Point Pattern Analysis",
    "text": "5.3 Network Constrained Point Pattern Analysis\n\nNetwork Kernel Density Estimation - To explore the intensity of points along network\nG and K function - To identify any potential clustering patterns, random distributions, even or uneven distributions of patterns"
  },
  {
    "objectID": "proposal.html#st-2nd-order-kernel-density-estimation",
    "href": "proposal.html#st-2nd-order-kernel-density-estimation",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.4 1st & 2nd Order Kernel Density Estimation",
    "text": "5.4 1st & 2nd Order Kernel Density Estimation\n\n1st order Kernel Density Estimation\nClarks Evans Test\n2nd Order G and K function analysis"
  },
  {
    "objectID": "proposal.html#user-interface-and-design",
    "href": "proposal.html#user-interface-and-design",
    "title": "Project Proposal: Spatial Bros",
    "section": "5.5 User Interface and Design",
    "text": "5.5 User Interface and Design\n\nAllow users to use the Interactive Shiny App easily, even without the user guide\nInstructions on interpretation of results will be provided on each individual KDE or statistical analysis page to allow users to understand results and formulate their conclusions\nExplanations of what each function and method that users are allowed to select for them to understand how each function/method works"
  },
  {
    "objectID": "proposal.html#network-constrained-and-category-based-point-pattern-analysis-for-suguo-retail-stores-in-nanjing-china",
    "href": "proposal.html#network-constrained-and-category-based-point-pattern-analysis-for-suguo-retail-stores-in-nanjing-china",
    "title": "Project Proposal: Spatial Bros",
    "section": "6.1 Network-constrained and category-based point pattern analysis for Suguo retail stores in Nanjing, China",
    "text": "6.1 Network-constrained and category-based point pattern analysis for Suguo retail stores in Nanjing, China\nhttps://www.tandfonline.com/doi/full/10.1080/13658816.2015.1080829\n\n6.1.1 Summary\nNetwork KDE and Network K-function was used to study retail service  hot-spot areas and spatial clustering patterns of a local retail giant, Suguo, in Nanjing City.\n\n\n6.1.2 Learning Points and Linking Back to Our Project\nThe bandwidth for generating network-constrained kernel density estimation (KDE) maps would produce representations of distributions that  and we should explore various network KDE bandwidths to find suitable bandwidth and also provide options for users to adjust bandwidth"
  },
  {
    "objectID": "proposal.html#identifying-factors-of-influence-in-the-spatial-distribution-of-domestic-fires",
    "href": "proposal.html#identifying-factors-of-influence-in-the-spatial-distribution-of-domestic-fires",
    "title": "Project Proposal: Spatial Bros",
    "section": "6.2 Identifying factors of influence in the spatial distribution of domestic fires",
    "text": "6.2 Identifying factors of influence in the spatial distribution of domestic fires\nhttps://doi.org/10.1080/13658810903143634\n\n6.2.1 Summary\nTo gain an understanding of how domestic fires arise based on different factors such as time of day, building types and income groups.\n\n\n\n6.2.2 Learning Points and Linking Back to Our Project\nThe use of the Strauss process for inferring different variables such as building types, income groups is an interesting way to generate random patterns of points where it stimulates the realization of the Strauss process. Developed by Strauss, Kelly and Ripley, it is a model for spatial inhibition that ranges from a strong ‘hard core’ inhibition to a completely random pattern according to gamma and beta value. The results also show that there are significant differences in factors that influence the spatial distribution of fires with the above variables listed."
  },
  {
    "objectID": "proposal.html#home-page",
    "href": "proposal.html#home-page",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.1 Home Page",
    "text": "7.1 Home Page"
  },
  {
    "objectID": "proposal.html#network-kde",
    "href": "proposal.html#network-kde",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.2 Network KDE",
    "text": "7.2 Network KDE"
  },
  {
    "objectID": "proposal.html#network-statistical-function",
    "href": "proposal.html#network-statistical-function",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.3 Network Statistical Function",
    "text": "7.3 Network Statistical Function"
  },
  {
    "objectID": "proposal.html#st-order-kde",
    "href": "proposal.html#st-order-kde",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.4 1st Order KDE",
    "text": "7.4 1st Order KDE"
  },
  {
    "objectID": "proposal.html#st-order-stat-function",
    "href": "proposal.html#st-order-stat-function",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.5 1st Order Stat Function",
    "text": "7.5 1st Order Stat Function"
  },
  {
    "objectID": "proposal.html#nd-order-stat-function",
    "href": "proposal.html#nd-order-stat-function",
    "title": "Project Proposal: Spatial Bros",
    "section": "7.6 2nd Order Stat Function",
    "text": "7.6 2nd Order Stat Function"
  },
  {
    "objectID": "unutilised/network_constraint_sp.html",
    "href": "unutilised/network_constraint_sp.html",
    "title": "Project: Spatial Bros",
    "section": "",
    "text": "Network constrained Spatial Point Patterns Analysis (NetSPAA) is a collection of spatial point patterns analysis methods special developed for analysing spatial point event occurs on or alongside network.\nThe spatial point event can be locations of childcare centre for example.\nThe network, on the other hand can be a road network for example.\nMore information with regards to data sources used for this project can be found at the proposal\n\n\n\nIn this project, x packages will be used\n\npacman::p_load(sp, sf, rgdal, spNetwork, tmap, readr, dplyr, ggplot2)\n\n\n\n\n\n\nImporting of shapefile, converting to EPSG of 7855 and converting Geometry Type to LINGSTRING.\n\nroad_network <- st_read(\"data/geospatial/Roads Network\", layer = \"road-corridors\")\nroad_network <- st_transform(road_network, crs = 7855)\nroad_network_lines <- st_boundary(road_network) %>% \n                     st_cast(\"LINESTRING\")\nwrite_rds(road_network_lines, \"SpatialBros/rds/road_network_lines.rds\")\n\n\n\n\n\npedestrian_network <- st_read(\"data/geospatial/Pedestrian Network/pedestrian-network.geojson\")\npedestrian_network <- st_transform(pedestrian_network, crs = 7855)\npedestrian_network <- pedestrian_network[st_geometry_type(st_geometry(pedestrian_network)) == \"LINESTRING\",]\nwrite_rds(pedestrian_network, \"SpatialBros/rds/pedestrian_network_lines.rds\")\n\n\n\n\n\ntram_network <- st_read(\"data/geospatial/Trams Network\", layer = \"PTV_METRO_TRAM_ROUTE\")\ntram_network <- st_transform(tram_network, crs = 7855)\nwrite_rds(tram_network, \"SpatialBros/rds/tram_network_lines.rds\")\n\n\n\n\nLocalities file downloaded was entire Australia. Therefore, we need to filter to retrieve localities of Melbourne.\n\nlocalities = st_read(\"data/geospatial/Localities\", layer = \"UCL_2021_AUST_GDA2020\") \nmelbourne_localities <- localities[localities$UCL_NAME21 == \"Melbourne\", ]\nmelbourne_localities <- st_transform(melbourne_localities, crs = 7855)\nwrite_rds(melbourne_localities, \"SpatialBros/rds/melbourne_localities.rds\")\n\n\n\n\nLocal Government Areas file downloaded was entire Australia. Therefore, we need to filter to retrieve Local Government Areas of Melbourne.\n\nlocal_government_areas = st_read(\"data/geospatial/Local Government Areas\", layer = \"LGA_2022_AUST_GDA2020\")\nmelbourne_local_government_areas = local_government_areas[local_government_areas$LGA_NAME22 == \"Melbourne\",]\nmelbourne_local_government_areas <- st_transform(melbourne_local_government_areas, crs = 7855)\nwrite_rds(melbourne_local_government_areas, \"SpatialBros/rds/melbourne_local_government_areas.rds\")\n\n\n\n\nTo retrieve only latest as of 2021 business establishments and is not vacant.\n\nbusiness_est_sp <- st_read(\"data/geospatial/Business Establishments Spatial Point/business-establishments-with-address-and-industry-classification.geojson\") %>% filter(census_year == \"2021\") %>% filter(trading_name != \"Vacant\")\nbusiness_est_sp <- st_transform(business_est_sp, crs = 7855)\nwrite_rds(business_est_sp, \"SpatialBros/rds/business_establishments.rds\")\n\n\n\n\n\ndrinking_fountain_sp <- st_read(\"data/geospatial/Drinking Fountain Spatial Point\", layer = \"drinking-fountains\")\ndrinking_fountain_sp <- st_transform(drinking_fountain_sp, crs = 7855)\nwrite_rds(drinking_fountain_sp, \"SpatialBros/rds/drinking_fountain.rds\")\n\n\n\n\n\nlandmarks_sp <- st_read(\"data/geospatial/Landmarks Spatial Point\", layer = \"landmarks-and-places-of-interest-including-schools-theatres-health-services-spor\")\nlandmarks_sp <- st_transform(landmarks_sp, crs = 7855)\nwrite_rds(landmarks_sp, \"SpatialBros/rds/landmarks.rds\")\n\n\n\n\n\nchildcare_sp <- read_csv(\"data/geospatial/Childcare Centres Spatial Point/childcare-centres.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\nchildcare_sp_sf <- st_as_sf(childcare_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\nwrite_rds(childcare_sp_sf, \"SpatialBros/rds/childcare.rds\")\n\n\n\n\n\nchildcare_spdf <- as(childcare_sp_sf, \"Spatial\")\nchildcare_spdf\n\n\n\n\n\n\npublic_toilets_sp <- read_csv(\"data/geospatial/Public Toilets Spatial Point/public-toilets.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\npublic_toilets_sp_sf <- st_as_sf(public_toilets_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\nwrite_rds(public_toilets_sp_sf, \"SpatialBros/rds/public_toilets.rds\")\n\n\n\n\n\npublic_toilets_spdf <- as(public_toilets_sp_sf, \"Spatial\")\npublic_toilets_spdf\n\n\n\n\n\n\n\n\n\ntmap_options('view')\nroad_network_be <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(business_est_sp) +\n  tm_dots(size = 0.02, col=\"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_cc <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_df <- tm_shape(road_network_lines) +\n tm_lines() +\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_landmarks <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\nroad_network_pt <- tm_shape(road_network_lines) +\n  tm_lines() +\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\nSaving road networks with all spatial points to a html file separately\n\ntmap_save(road_network_cc, \"tmaphtml/road_network_cc.html\")\ntmap_save(road_network_be, \"tmaphtml/road_network_be.html\")\ntmap_save(road_network_df, \"tmaphtml/road_network_df.html\")\ntmap_save(road_network_landmarks, \"tmaphtml/road_network_landmarks.html\")\ntmap_save(road_network_pt, \"tmaphtml/road_network_pt.html\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_be <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(business_est_sp) +\n  tm_dots(size = 0.02, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_cc <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_df <- tm_shape(pedestrian_network) +\n tm_lines() +\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_landmarks <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\npedestrian_network_pt <- tm_shape(pedestrian_network) +\n  tm_lines() +\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\nSaving pedestrian networks with all spatial points to a html file separately\n\ntmap_save(pedestrian_network_cc, \"tmaphtml/pedestrian_network_cc.html\")\ntmap_save(pedestrian_network_be, \"tmaphtml/pedestrian_network_be.html\")\ntmap_save(pedestrian_network_df, \"tmaphtml/pedestrian_network_df.html\")\ntmap_save(pedestrian_network_landmarks, \"tmaphtml/pedestrian_network_landmarks.html\")\ntmap_save(pedestrian_network_pt, \"tmaphtml/pedestrian_network_pt.html\")\n\n\n\n\n\ntmap_options('view')\ntram_network_be <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(business_est_sp) +\n  tm_dots(size = 0.02, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_cc <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_df <- tm_shape(tram_network) +\n tm_lines() +\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_landmarks <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_options('view')\ntram_network_pt <- tm_shape(tram_network) +\n  tm_lines() +\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\nSaving tram networks with all spatial points to a html file separately\n\ntmap_save(tram_network_cc, \"tmaphtml/tram_network_cc.html\")\ntmap_save(tram_network_be, \"tmaphtml/tram_network_be.html\")\ntmap_save(tram_network_df, \"tmaphtml/tram_network_df.html\")\ntmap_save(tram_network_landmarks, \"tmaphtml/tram_network_landmarks.html\")\ntmap_save(tram_network_pt, \"tmaphtml/tram_network_pt.html\")\n\n\n\n\n\nIn this section, we will perform NetKDE analysis by using appropriate functions provided in spNetwork package.\n\n\nBefore computing NetKDE, the SpatialLines object need to be cut into lixels with a specified minimal distance. This task can be performed by using with lixelize_lines() of spNetwork as shown in the code chunk below.\n\n# Lixels for Road Network\nroad_lixels_cc <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_be <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_df <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_lm <- lixelize_lines(road_network_lines, 1000, mindist = 350)\nroad_lixels_pt <- lixelize_lines(road_network_lines, 1000, mindist = 350)\n\n# Lixels for Pedestrian Network\npedestrian_lixels_cc <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_be <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_df <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_lm <- lixelize_lines(pedestrian_network, 500, mindist = 250)\npedestrian_lixels_pt <- lixelize_lines(pedestrian_network, 500, mindist = 250)\n\n# Lixels for Tram Network\ntram_lixels_cc <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_be <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_df <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_lm <- lixelize_lines(tram_network, 1000, mindist = 350)\ntram_lixels_pt <- lixelize_lines(tram_network, 1000, mindist = 350)\n\nThe length of a lixel, lx_length is set to 1000m, 500m and 1000m respectively for road_network, pedestrian_network and tram_network. The minimum length of a lixel, mindist is set to 350m for network of road and tram whereas 250m for pedestrian network.\n\n\n\nNext, lines_center() of spNetwork will be used to generate a SpatialPointsDataFrame (i.e. samples) with line centre points as shown in the code chunk below.\n\n# Road network lines center\nroad_samples_cc <- lines_center(road_lixels_cc)\nroad_samples_be <- lines_center(road_lixels_be)\nroad_samples_df <- lines_center(road_lixels_df)\nroad_samples_lm <- lines_center(road_lixels_lm)\nroad_samples_pt <- lines_center(road_lixels_pt)\n\n# Pedestrian network lines center\npedestrian_samples_cc <- lines_center(pedestrian_lixels_cc)\npedestrian_samples_be <- lines_center(pedestrian_lixels_be)\npedestrian_samples_df <- lines_center(pedestrian_lixels_df)\npedestrian_samples_lm <- lines_center(pedestrian_lixels_lm)\npedestrian_samples_pt <- lines_center(pedestrian_lixels_pt)\n\n# # Tram network lines center\ntram_samples_cc <- lines_center(tram_lixels_cc)\ntram_samples_be <- lines_center(tram_lixels_be)\ntram_samples_df <- lines_center(tram_lixels_df)\ntram_samples_lm <- lines_center(tram_lixels_lm)\ntram_samples_pt <- lines_center(tram_lixels_pt)\n\n\n\n\nWe are ready to compute the NetKDE by using the code chunk below.\n\n\n\nroad_network_cc_densities <- nkde(road_network_lines, \n                  events = childcare_sp_sf,\n                  w = rep(1,nrow(childcare_sp_sf)),\n                  samples = road_samples_cc,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_be_densities <- nkde(road_network_lines, \n                  events = business_est_sp,\n                  w = rep(1,nrow(business_est_sp)),\n                  samples = road_samples_be,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_df_densities <- nkde(road_network_lines, \n                  events = drinking_fountain_sp,\n                  w = rep(1,nrow(drinking_fountain_sp)),\n                  samples = road_samples_df,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_lm_densities <- nkde(road_network_lines, \n                  events = landmarks_sp,\n                  w = rep(1,nrow(landmarks_sp)),\n                  samples = road_samples_lm,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nroad_network_pt_densities <- nkde(road_network_lines, \n                  events = public_toilets_sp_sf,\n                  w = rep(1,nrow(public_toilets_sp_sf)),\n                  samples = road_samples_pt,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nBefore we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.\n\nroad_samples_cc$density <- road_network_cc_densities * 1000\nroad_lixels_cc$density <- road_network_cc_densities * 1000\n\nroad_samples_be$density <- road_network_be_densities * 1000\nroad_lixels_be$density <- road_network_be_densities * 1000\n\nroad_samples_df$density <- road_network_df_densities * 1000\nroad_lixels_df$density <- road_network_df_densities * 1000\n\nroad_samples_lm$density <- road_network_lm_densities * 1000\nroad_lixels_lm$density <- road_network_lm_densities * 1000\n\nroad_samples_pt$density <- road_network_pt_densities * 1000\nroad_lixels_pt$density <- road_network_pt_densities * 1000\n\n\n\n\ntmap_options('view')\nroad_networkKDE_cc <- tm_shape(road_lixels_cc) +\n  tm_lines(col=\"density\")+\n  tm_shape(childcare_spdf)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_be <- tm_shape(road_lixels_be) +\n  tm_lines(col=\"density\")+\n  tm_shape(business_est_sp)+\n  tm_dots(size = 0.02)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_df <- tm_shape(road_lixels_df) +\n  tm_lines(col=\"density\")+\n  tm_shape(drinking_fountain_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_lm <- tm_shape(road_lixels_lm) +\n  tm_lines(col=\"density\")+\n  tm_shape(landmarks_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\nroad_networkKDE_pt <- tm_shape(road_lixels_pt) +\n  tm_lines(col=\"density\")+\n  tm_shape(public_toilets_spdf)+\n  tm_dots(size = 0.03)\n\nSaving road networks KDE to separate html file\n\ntmap_save(road_networkKDE_cc, \"tmapnetworkKDEhtml/road_networkKDE_cc.html\")\ntmap_save(road_networkKDE_be, \"tmapnetworkKDEhtml/road_networkKDE_be.html\")\ntmap_save(road_networkKDE_df, \"tmapnetworkKDEhtml/road_networkKDE_df.html\")\ntmap_save(road_networkKDE_lm, \"tmapnetworkKDEhtml/road_networkKDE_lm.html\")\ntmap_save(road_networkKDE_pt, \"tmapnetworkKDEhtml/road_networkKDE_pt.html\")\n\n\n\n\n\nWe are ready to compute the NetKDE by using the code chunk below. When using the continuous and discontinuous methods, the calculation time and memory use can go wild if the network has many small edges (area with many of intersections and many events) - especially for pedestrian network. To avoid it, it is possible to set here a maximum depth. Considering that the kernel is divided at intersections, a value of max_depth value of 10 is set and should yield good estimates in most cases. (https://cran.r-project.org/web/packages/spNetwork/spNetwork.pdf)\n\n\n\npedestrian_network_cc_densities <- nkde(pedestrian_network, \n                  events = childcare_sp_sf,\n                  w = rep(1,nrow(childcare_sp_sf)),\n                  samples = pedestrian_samples_cc,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_be_densities <- nkde(pedestrian_network, \n                  events = business_est_sp,\n                  w = rep(1,nrow(business_est_sp)),\n                  samples = pedestrian_samples_be,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_df_densities <- nkde(pedestrian_network, \n                  events = drinking_fountain_sp,\n                  w = rep(1,nrow(drinking_fountain_sp)),\n                  samples = pedestrian_samples_df,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_lm_densities <- nkde(pedestrian_network, \n                  events = landmarks_sp,\n                  w = rep(1,nrow(landmarks_sp)),\n                  samples = pedestrian_samples_lm,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\npedestrian_network_pt_densities <- nkde(pedestrian_network, \n                  events = public_toilets_sp_sf,\n                  w = rep(1,nrow(public_toilets_sp_sf)),\n                  samples = pedestrian_samples_pt,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 1, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 10,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nBefore we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.\n\npedestrian_samples_cc$density <- pedestrian_network_cc_densities * 1000\npedestrian_lixels_cc$density <- pedestrian_network_cc_densities * 1000 \n\npedestrian_samples_be$density <- pedestrian_network_be_densities * 1000\npedestrian_lixels_be$density <- pedestrian_network_be_densities * 1000\n\npedestrian_samples_df$density <- pedestrian_network_df_densities * 1000\npedestrian_lixels_df$density <- pedestrian_network_df_densities * 1000\n\npedestrian_samples_lm$density <- pedestrian_network_lm_densities * 1000\npedestrian_lixels_lm$density <- pedestrian_network_lm_densities * 1000\n\npedestrian_samples_pt$density <- pedestrian_network_pt_densities * 1000\npedestrian_lixels_pt$density <- pedestrian_network_pt_densities * 1000\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_cc <- tm_shape(pedestrian_lixels_cc) +\n  tm_lines(col=\"density\")+\n  tm_shape(childcare_spdf)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_be <- tm_shape(pedestrian_lixels_be) +\n  tm_lines(col=\"density\")+\n  tm_shape(business_est_sp)+\n  tm_dots(size = 0.02)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_df <- tm_shape(pedestrian_lixels_df) +\n  tm_lines(col=\"density\")+\n  tm_shape(drinking_fountain_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_lm <- tm_shape(pedestrian_lixels_lm) +\n  tm_lines(col=\"density\")+\n  tm_shape(landmarks_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\npedestrian_networkKDE_pt <- tm_shape(pedestrian_lixels_pt) +\n  tm_lines(col=\"density\")+\n  tm_shape(public_toilets_spdf)+\n  tm_dots(size = 0.03)\n\nSaving road networks KDE to separate html file\n\ntmap_save(pedestrian_networkKDE_cc, \"tmapnetworkKDEhtml/pedestrian_networkKDE_cc.html\")\ntmap_save(pedestrian_networkKDE_be, \"tmapnetworkKDEhtml/pedestrian_networkKDE_be.html\")\ntmap_save(pedestrian_networkKDE_df, \"tmapnetworkKDEhtml/pedestrian_networkKDE_df.html\")\ntmap_save(pedestrian_networkKDE_lm, \"tmapnetworkKDEhtml/pedestrian_networkKDE_lm.html\")\ntmap_save(pedestrian_networkKDE_pt, \"tmapnetworkKDEhtml/pedestrian_networkKDE_pt.html\")\n\n\n\n\n\nWe are ready to compute the NetKDE by using the code chunk below.\n\n\n\ntram_network_cc_densities <- nkde(tram_network, \n                  events = childcare_sp_sf,\n                  w = rep(1,nrow(childcare_sp_sf)),\n                  samples = tram_samples_cc,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_be_densities <- nkde(tram_network, \n                  events = business_est_sp,\n                  w = rep(1,nrow(business_est_sp)),\n                  samples = tram_samples_be,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_df_densities <- nkde(tram_network, \n                  events = drinking_fountain_sp,\n                  w = rep(1,nrow(drinking_fountain_sp)),\n                  samples = tram_samples_df,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_lm_densities <- nkde(tram_network, \n                  events = landmarks_sp,\n                  w = rep(1,nrow(landmarks_sp)),\n                  samples = tram_samples_lm,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\ntram_network_pt_densities <- nkde(tram_network, \n                  events = public_toilets_sp_sf,\n                  w = rep(1,nrow(public_toilets_sp_sf)),\n                  samples = tram_samples_pt,\n                  kernel_name = \"quartic\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = \"simple\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 20, #we aggregate events within a 20m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\n\n\nBefore we can visualise the NetKDE values, code chunk below will be used to insert the computed density values (i.e. densities) into samples and lixels objects as density field.\n\ntram_samples_cc$density <- tram_network_cc_densities * 1000\ntram_lixels_cc$density <- tram_network_cc_densities * 1000 \n\ntram_samples_be$density <- tram_network_be_densities * 1000\ntram_lixels_be$density <- tram_network_be_densities * 1000\n\ntram_samples_df$density <- tram_network_df_densities * 1000\ntram_lixels_df$density <- tram_network_df_densities * 1000\n\ntram_samples_lm$density <- tram_network_lm_densities * 1000\ntram_lixels_lm$density <- tram_network_lm_densities * 1000\n\ntram_samples_pt$density <- tram_network_pt_densities * 1000\ntram_lixels_pt$density <- tram_network_pt_densities * 1000\n\n\n\n\ntmap_options('view')\ntram_networkKDE_cc <- tm_shape(tram_lixels_cc) +\n  tm_lines(col=\"density\")+\n  tm_shape(childcare_spdf)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_be <- tm_shape(tram_lixels_be) +\n  tm_lines(col=\"density\")+\n  tm_shape(business_est_sp)+\n  tm_dots(size = 0.02)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_df <- tm_shape(tram_lixels_df) +\n  tm_lines(col=\"density\")+\n  tm_shape(drinking_fountain_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_lm <- tm_shape(tram_lixels_lm) +\n  tm_lines(col=\"density\")+\n  tm_shape(landmarks_sp)+\n  tm_dots(size = 0.03)\n\n\n\n\n\ntmap_options('view')\ntram_networkKDE_pt <- tm_shape(tram_lixels_pt) +\n  tm_lines(col=\"density\")+\n  tm_shape(public_toilets_spdf)+\n  tm_dots(size = 0.03)\n\nSaving tram networks KDE to separate html file\n\ntmap_save(tram_networkKDE_cc, \"tmapnetworkKDEhtml/tram_networkKDE_cc.html\")\ntmap_save(tram_networkKDE_be, \"tmapnetworkKDEhtml/tram_networkKDE_be.html\")\ntmap_save(tram_networkKDE_df, \"tmapnetworkKDEhtml/tram_networkKDE_df.html\")\ntmap_save(tram_networkKDE_lm, \"tmapnetworkKDEhtml/tram_networkKDE_lm.html\")\ntmap_save(tram_networkKDE_pt, \"tmapnetworkKDEhtml/tram_networkKDE_pt.html\")\n\n\n\n\n\n\nIn this section, we are going to perform complete spatial randomness (CSR) test by using kfunctions() of spNetwork package. The null hypothesis is defined as:\n\n\nHo: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of business establishments) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of drinking fountain) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of landmarks) are uniformly distributed over a road network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of public toilets) are uniformly distributed over a pedestrian network in Melbourne City Area.\n\n\n\nHo: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of business establishments) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of drinking fountain) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of landmarks) are uniformly distributed over a pedestrian network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of public toilets) are uniformly distributed over a pedestrian network in Melbourne City Area.\n\n\n\nHo: The observed spatial point events (i.e distribution of childcare centres) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of business establishments) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of drinking fountain) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of landmarks) are uniformly distributed over a tram network in Melbourne City Area.\nHo: The observed spatial point events (i.e distribution of public toilets) are uniformly distributed over a tram network in Melbourne City Area.\nThe CSR test is based on the assumption of the binomial point process which implies the hypothesis that the spatial points are randomly and independently distributed over the various network.\nIf this hypothesis is rejected, we may infer that the distribution of spatial points are spatially interacting and dependent on each other; as a result, they may form nonrandom patterns.\n\n\n\n\n\n\nkfun_childcare_road <- kfunctions(road_network_lines, \n                             childcare_sp_sf,\n                             start = 0, \n                             end = 1000, \n                             step = 100, \n                             width = 50, \n                             nsim = 100, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n\n\nkfun_childcare_road <- kfun_childcare_road$plotk\n\n\n\n\n\nbusiness_est_sp_unique <- business_est_sp[!duplicated(st_geometry(business_est_sp)), ]\nkfun_be_road <- kfunctions(road_network_lines, \n                           business_est_sp_unique,\n                           start = 0, \n                           end = 1000, \n                           step = 100, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 100,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_be_road <- kfun_be_road$plotk\n\n\n\n\n\nkfun_df_road <- kfunctions(road_network_lines, \n                           drinking_fountain_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_df_road <- kfun_df_road$plotk\n\n\n\n\n\nkfun_lm_road <- kfunctions(road_network_lines, \n                           landmarks_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 100,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\n#kfun_lm_road <- kfun_lm_road$plotk\nkfun_lm_road$plotk\n\n\n\n\n\npublic_toilets_sp_sf_unique <- public_toilets_sp_sf[!duplicated(st_geometry(public_toilets_sp_sf)), ]\nkfun_pt_road <- kfunctions(road_network_lines, \n                           public_toilets_sp_sf,\n                           start = 0, \n                           end = 1000, \n                           step = 100, \n                           width = 50, \n                           nsim = 50,\n                           agg = 100,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_pt_road <- kfun_pt_road$plotk\n\n\nggsave(file = \"g&kplot/kfun_childcare_road.png\", plot = kfun_childcare_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_be_road.png\", plot = kfun_be_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_df_road.png\", plot = kfun_df_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_lm_road.png\", plot = kfun_lm_road, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_pt_road.png\", plot = kfun_pt_road, width = 6, height = 4, dpi = 300)\n\n\n\n\n\nkfun_childcare_pedestrian <- kfunctions(pedestrian_network, \n                             childcare_sp_sf,\n                             start = 0, \n                             end = 1000, \n                             step = 50, \n                             width = 50, \n                             nsim = 50, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n\n\nkfun_childcare_pedestrian <- kfun_childcare_pedestrian$plotk\n\n\n\n\n\nbusiness_est_sp_unique <- business_est_sp[!duplicated(st_geometry(business_est_sp)), ]\nkfun_be_pedestrian <- kfunctions(pedestrian_network, \n                           business_est_sp_unique,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 100,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_be_pedestrian <- kfun_be_pedestrian$plotk\n\n\n\n\n\nkfun_df_pedestrian <- kfunctions(pedestrian_network, \n                           drinking_fountain_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_df_pedestrian <- kfun_df_pedestrian$plotk\n\n\n\n\n\nkfun_lm_pedestrian <- kfunctions(pedestrian_network, \n                           landmarks_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_lm_pedestrian <- kfun_lm_pedestrian$plotk\n\n\n\n\n\npublic_toilets_sp_sf_unique <- public_toilets_sp_sf[!duplicated(st_geometry(public_toilets_sp_sf)), ]\nkfun_pt_pedestrian <- kfunctions(pedestrian_network, \n                           public_toilets_sp_sf,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50,\n                           agg = 100,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_pt_pedestrian <- kfun_pt_pedestrian$plotk\n\n\nggsave(file = \"g&kplot/kfun_childcare_pedestrian.png\", plot = kfun_childcare_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_be_pedestrian.png\", plot = kfun_be_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_df_pedestrian.png\", plot = kfun_df_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_lm_pedestrian.png\", plot = kfun_lm_pedestrian, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_pt_pedestrian.png\", plot = kfun_pt_pedestrian, width = 6, height = 4, dpi = 300)\n\n\n\n\n\nkfun_childcare_tram <- kfunctions(tram_network, \n                             childcare_sp_sf,\n                             start = 0, \n                             end = 500, \n                             step = 50, \n                             width = 50, \n                             nsim = 50, \n                             resolution = 50,\n                             verbose = FALSE, \n                             conf_int = 0.05)\n\n\nkfun_childcare_tram <- kfun_childcare_tram$plotk\n\n\n\n\n\nbusiness_est_sp_unique <- business_est_sp[!duplicated(st_geometry(business_est_sp)), ]\nkfun_be_tram <- kfunctions(tram_network, \n                           business_est_sp_unique,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 500,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_be_tram <- kfun_be_tram$plotk\n\n\n\n\n\nkfun_df_tram <- kfunctions(tram_network, \n                           drinking_fountain_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 500,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_df_tram <- kfun_df_tram$plotk\n\n\n\n\n\nkfun_lm_tram <- kfunctions(tram_network, \n                           landmarks_sp,\n                           start = 0, \n                           end = 250, \n                           step = 50, \n                           width = 50, \n                           nsim = 50, \n                           resolution = 50,\n                           agg = 700,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_lm_tram <- kfun_lm_tram$plotk\n\n\n\n\n\npublic_toilets_sp_sf_unique <- public_toilets_sp_sf[!duplicated(st_geometry(public_toilets_sp_sf)), ]\nkfun_pt_tram <- kfunctions(tram_network, \n                           public_toilets_sp_sf,\n                           start = 0, \n                           end = 1000, \n                           step = 50, \n                           width = 50, \n                           nsim = 50,\n                           agg = 500,\n                           resolution = 50,\n                           verbose = FALSE, \n                           conf_int = 0.05)\n\n\nkfun_pt_tram <- kfun_pt_tram$plotk\n\n\nggsave(file = \"g&kplot/kfun_childcare_tram.png\", plot = kfun_childcare_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_be_tram.png\", plot = kfun_be_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_df_tram.png\", plot = kfun_df_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_lm_tram.png\", plot = kfun_lm_tram, width = 6, height = 4, dpi = 300)\nggsave(file = \"g&kplot/kfun_pt_tram.png\", plot = kfun_pt_tram, width = 6, height = 4, dpi = 300)"
  },
  {
    "objectID": "unutilised/nkde_consolidation.html",
    "href": "unutilised/nkde_consolidation.html",
    "title": "NKDE_Consolidation",
    "section": "",
    "text": "Preparing the lixels objects\n\n#we let user_input_lx_length we set default 1000\n#we let user_input_mindist we set default 350 \nroad_lixels_cc <- lixelize_lines(network_name, user_input_lx_length, mindist = user_input_mindist)\n\n\n\nGenerating line centre points\n\nroad_samples_cc <- lines_center(road_lixels_cc)\n\n\n\nCompute NKDE\n\n#we let user input kernel_type default = \"quartic\"\n#we let user input method_type default = \"simple\"\nroad_network_cc_densities <- nkde(#network name, <- from RDS example road\n                  events = #spatial_point, <- from RDS example childcare\n                  w = rep(1,nrow(#spatial_point)), <- from RDS example childcare\n                  samples = #road_samples_cc, <- dependent on code line 16\n                  kernel_name = # \"kernel_type\",\n                  bw = 300, \n                  div= \"bw\", \n                  method = #\"method_type\", \n                  digits = 3, \n                  tol = 1,\n                  grid_shape = c(1,1), \n                  max_depth = 8,\n                  agg = 10, #we aggregate events within a 10m radius (faster calculation)\n                  sparse = TRUE,\n                  verbose = FALSE)\n\n\n\nRescaling Density Values\n\nroad_samples_cc$density <- road_network_cc_densities * 1000\nroad_lixels_cc$density <- road_network_cc_densities * 1000\n\n\n\nPlotting NKDE\n\ntmap_options('view')\nroad_networkKDE_cc <- tm_shape(#road_lixels_cc) + <- dependent on line 44\n  tm_lines(col=\"density\")+\n  tm_shape(#spatial_point)+ <- from RDS example childcare\n  tm_dots(size = 0.03) +\n    tm_shape(#melbourne_localities) + you may need to double check this from RDS and add above\n      tm_polygons() \ntmap_mode('plot')\n\n\n\nNetwork Constrained G- and K-Function Analysis\n\nkfun_childcare <- kfunctions(road_network_lines, \n           childcare_sp_sf,\n           start = 0, # user input\n           end = 1000, # user input \n           step = 100, \n           width = 50, \n           nsim = 100, # user input number of simulations\n           resolution = 50,\n           verbose = FALSE,\n           agg = 100, # user input let them pick 0 to 1000 \n           conf_int = 0.05)\n\nkfun_childcare$plotk"
  },
  {
    "objectID": "unutilised/sp.html",
    "href": "unutilised/sp.html",
    "title": "Project: Spatial Bros",
    "section": "",
    "text": "Spatial Point Patterns Analysis.\nThe spatial point event can be locations of childcare centre for example.\nMore information with regards to data sources used for this project can be found at the proposal\n\n\n\nIn this project, x packages will be used\n\npacman::p_load(sp, sf, rgdal, spNetwork, tmap, readr, dplyr, ggplot2, spatstat, maptools)\n\n\n\n\n\n\nLocalities file downloaded was entire Australia. Therefore, we need to filter to retrieve localities of Melbourne.\n\nlocalities = st_read(\"data/geospatial/Localities\", layer = \"vic_localities\") \n#melbourne_localities <- localities[localities$UCL_NAME21 == \"Melbourne\", ]\n#melbourne_localities <- st_transform(melbourne_localities, crs = 7855)\n\n\n\n\nLocal Government Areas file downloaded was entire Australia. Therefore, we need to filter to retrieve Local Government Areas of Melbourne.\n\nlocal_government_areas = st_read(\"data/geospatial/Local Government Areas\", layer = \"LGA_2022_AUST_GDA2020\")\nmelbourne_local_government_areas = local_government_areas[local_government_areas$LGA_NAME22 == \"Melbourne\",]\nmelbourne_local_government_areas <- st_transform(melbourne_local_government_areas, crs = 7855)\n\n\n\n\nTo retrieve only latest as of 2021 business establishments and is not vacant.\n\nbusiness_est_sp <- st_read(\"data/geospatial/Business Establishments Spatial Point/business-establishments-with-address-and-industry-classification.geojson\") %>% filter(census_year == \"2021\") %>% filter(trading_name != \"Vacant\")\nbusiness_est_sp <- st_transform(business_est_sp, crs = 7855) \n\n\n\n\n\ndrinking_fountain_sp <- st_read(\"data/geospatial/Drinking Fountain Spatial Point\", layer = \"drinking-fountains\")\ndrinking_fountain_sp <- st_transform(drinking_fountain_sp, crs = 7855)\n\n\n\n\n\nlandmarks_sp <- st_read(\"data/geospatial/Landmarks Spatial Point\", layer = \"landmarks-and-places-of-interest-including-schools-theatres-health-services-spor\")\nlandmarks_sp <- st_transform(landmarks_sp, crs = 7855)\n\n\n\n\n\nchildcare_sp <- read_csv(\"data/geospatial/Childcare Centres Spatial Point/childcare-centres.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\nchildcare_sp_sf <- st_as_sf(childcare_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\n\n\n\n\n\nchildcare_spdf <- as(childcare_sp_sf, \"Spatial\")\nchildcare_spdf\n\n\n\n\n\n\npublic_toilets_sp <- read_csv(\"data/geospatial/Public Toilets Spatial Point/public-toilets.csv\")\n\n\n\nUpon research, it was found that EPSG: 4326 is wGS84 Geographic Coordinate System, therefore we have to convert it to Melbourne’s GDA2020 / MGA zone 55 – EPSG:7855 (https://parametricmonkey.com/2020/04/08/understanding-australias-coordinate-systems/)\n\npublic_toilets_sp_sf <- st_as_sf(public_toilets_sp, \n                       coords = c(\"lon\", \"lat\"),\n                       crs=4326) %>%\n  st_transform(crs = 7855)\n\n\n\n\n\npublic_toilets_spdf <- as(public_toilets_sp_sf, \"Spatial\")\npublic_toilets_spdf\n\n\n\n\n\n\n\n\n\ntmap_mode(\"view\")\n  tm_shape(business_est_sp) +\n  tm_dots(\"industry_anzsic4_description\", size = 0.02, popup.vars = c(\"industry_anzsic4_description\" = \"industry_anzsic4_description\"))\n\n\n\n\n\ntmap_mode(\"view\")\n  tm_shape(childcare_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_mode('view')\n tm_shape(drinking_fountain_sp) +\n tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_mode('view')\n  tm_shape(landmarks_sp) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\ntmap_mode('view')\n  tm_shape(public_toilets_spdf) +\n  tm_dots(size = 0.03, col = \"green\")\n\n\n\n\n\nUsing spatstat, we will\n\n\n\nbusiness_est_gsp <- as_Spatial(business_est_sp)\nchildcare_gsp <- as_Spatial(childcare_sp_sf)\ndrinking_fountain_gsp <- as_Spatial(drinking_fountain_sp)\nlandmarks_gsp <- as_Spatial(landmarks_sp)\npublic_toilets_gsp <- as_Spatial(public_toilets_sp_sf)\n\n\n\n\n\nbusiness_est_spc <- as(business_est_gsp, \"SpatialPoints\")\nchildcare_spc <- as(childcare_gsp, \"SpatialPoints\")\ndrinking_fountain_spc <- as(drinking_fountain_gsp, \"SpatialPoints\")\nlandmarks_spc <- as(landmarks_gsp, \"SpatialPoints\")\npublic_toilets_spc <- as(public_toilets_gsp, \"SpatialPoints\")\n\n\n\n\n\nbusiness_est_ppp <- as.ppp(business_est_spc)\nchildcare_ppp <- as.ppp(childcare_spc)\ndrinking_fountain_ppp <- as.ppp(drinking_fountain_spc)\nlandmarks_ppp <- as.ppp(landmarks_spc)\npublic_toilets_ppp <- as.ppp(public_toilets_spc)\n\n\n\n\n\nany(duplicated(business_est_ppp))\nany(duplicated(childcare_ppp))\nany(duplicated(drinking_fountain_ppp))\nany(duplicated(landmarks_ppp))\nany(duplicated(public_toilets_ppp))\n\n\n\n\n\nmultiplicity(business_est_ppp)\nsum(multiplicity(business_est_ppp) > 1)\n\nHandling duplicated events using jitter to slightly offset them\n\nbusiness_est_ppp_jit <- rjitter(business_est_ppp,\n                             retry = TRUE,\n                             nsim = 1,\n                             drop = TRUE)\n\nany(duplicated(business_est_ppp_jit))\n\n\n\n\n\nmelbourne_lga_spat <- as_Spatial(melbourne_local_government_areas)\nmelbourne_lga_sp <- as(melbourne_lga_spat, \"SpatialPolygons\")\nmelbourne_lga_owin <- as(melbourne_lga_sp, \"owin\")\n\n\nplot(melbourne_lga_owin)\n\nsummary(melbourne_lga_owin)\n\n\n\n\n\nbusiness_est_jit_melb_ppp = business_est_ppp_jit[melbourne_lga_owin]\nchildcare_melb_ppp = childcare_ppp[melbourne_lga_owin]\ndrinking_fountai_melb_ppp = drinking_fountain_ppp[melbourne_lga_owin]\nlandmarks_melb_ppp = landmarks_ppp[melbourne_lga_owin]\npublic_toilets_melb_ppp = public_toilets_ppp[melbourne_lga_owin]\n\n\nsummary(business_est_jit_melb_ppp)\nsummary(childcare_melb_ppp)\nsummary(drinking_fountai_melb_ppp)\nsummary(landmarks_melb_ppp)\nsummary(public_toilets_melb_ppp)\n\n\nplot(business_est_jit_melb_ppp)\nplot(childcare_melb_ppp)\nplot(drinking_fountai_melb_ppp)\nplot(landmarks_melb_ppp)\nplot(public_toilets_melb_ppp)\n\n\n\n\n\nbusiness_est_jit_melb_ppp.km <- rescale(business_est_jit_melb_ppp, 1000, \"km\")\nchildcare_melb_ppp.km <- rescale(childcare_melb_ppp, 1000, \"km\")\ndrinking_fountai_melb_ppp.km <- rescale(drinking_fountai_melb_ppp, 1000, \"km\")\nlandmarks_melb_ppp.km <- rescale(landmarks_melb_ppp, 1000, \"km\")\npublic_toilets_melb_ppp.km <- rescale(public_toilets_melb_ppp, 1000, \"km\")\n\n\n\n\n\npar(mfrow=c(2,2))\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"gaussian\"), \n             main = \"Gaussian\")\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"epanechnikov\"), \n             main = \"Epanechnikov\")\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"quartic\"), \n             main = \"Quartic\")\nplot(density(business_est_jit_melb_ppp.km, \n             sigma = bw.ppl, \n             edge = TRUE, \n             kernel = \"disc\"), \n             main = \"Disc\")\n\n\n\n\n\nkde_businessMB_adaptive <- adaptive.density(business_est_jit_melb_ppp.km, method = \"kernel\")\nplot(kde_businessMB_adaptive)\n\n\nkde_childcareMB_adaptive <- adaptive.density(childcare_melb_ppp.km, method = \"kernel\")\nplot(kde_childcareMB_adaptive)\n\n\nkde_drinkMB_adaptive <- adaptive.density(drinking_fountai_melb_ppp.km, method = \"kernel\")\nplot(kde_drinkMB_adaptive)\n\n\nkde_landmMB_adaptive <- adaptive.density(landmarks_melb_ppp.km, method = \"kernel\")\nplot(kde_landmMB_adaptive)\n\n\nkde_pubtoilet_adaptive <- adaptive.density(public_toilets_melb_ppp.km, method = \"kernel\")\nplot(kde_pubtoilet_adaptive)\n\n\n  kde.grid <- as.SpatialGridDataFrame.im(kde_pubtoilet_adaptive)\n  kde_raster <- raster(kde.grid)\nkde.grid <- CRS(SRS_string = \"EPSG:7855\")\ntm_shape(kde_raster) +\n  tm_raster(\"v\")\n\n\nkde.grid"
  },
  {
    "objectID": "unutilised/UntitledQMD.html",
    "href": "unutilised/UntitledQMD.html",
    "title": "",
    "section": "",
    "text": "install.packages(\"sf_1.0-9.tar.gz\", repos = NULL, type=\"source\")\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(sp)\nlibrary(sf)\nlibrary(rgdal)\nlibrary(spNetwork)\nlibrary(tmap)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(plotly)\n\n\nloc <- read_rds(\"rds/melbourne_localities.rds\")\n\n\nloc <- st_transform(loc, crs = 7855)\n\n\nplot(loc)\n\n\nboundary <- read_rds(\"rds/melbourne_local_government_areas.rds\")\n\n\nboundary <- st_transform(boundary, crs = 7855)\n\n\nlocalities = st_read(\"test/\", layer = \"vic_localities\") \n\n\nlocalities <- st_transform(localities, crs = 7855)\n\n\ntest <- localities %>% filter(LOC_NAME %in% c(\"Carlton\", \"Carlton North\", \"Docklands\", \"East Melbourne\", \"Flemington\", \"Kensington\", \"Melbourne\", \"North Melbourne\", \"Parkville\", \"Port Melbourne\", \"South Wharf\", \"South Yarra\", \"Southbank\", \"West Melbourne\"))\n\n\nplot(test)\nplot(boundary)\n\n\nsaveRDS(test, \"rds/melbourne_localities.rds\")\n\n\ntest3\nboundary\n\n\ntest3 <- localities %>% filter(LOC_NAME == \"Flemington\")\n\ntest2 <- st_intersection(boundary, test)\n\n\nplot(test2)\n\n\nsaveRDS(test2, \"rds/melbourne_localities.rds\")\n\n\nnet_lines <- read_rds(\"rds/road_network_lines.rds\")\nnet_lines\n\n\nhi <- st_intersection(net_lines, boundary)\n\n\nloc_interest = read_rds(\"rds/drinking_fountain.rds\")\nnetwork_type = read_rds(\"rds/road_network_lines.rds\")\n\n      adaptive = FALSE\n      trim_bw = NULL\n\n    \n    cv_scores <- bw_cv_likelihood_calc(c(200,800),50,\n                             network_type, loc_interest,\n                             rep(1,nrow(loc_interest)),\n                             \"quartic\", \"simple\" , verbose=FALSE, check=TRUE)\n    max_index <- which.max(cv_scores[,2])\n    max_bandwidth <- cv_scores[max_index, 1]\n\n    road_lixels_cc <- lixelize_lines(network_type, 700, mindist = 350)\n    road_samples_cc <- lines_center(road_lixels_cc)\n    road_network_cc_densities <- nkde(network_type,\n                                      events = loc_interest,\n                                      w = rep(1,nrow(loc_interest)), \n                                      samples = road_samples_cc, \n                                      kernel_name =  noquote(input$kernel_name),\n                                      bw = max_bandwidth, \n                                      trim_bw = trim_bw,\n                                      div= \"bw\", \n                                      adaptive = adaptive,\n                                      method = noquote(input$method_name), \n                                      digits = 3, \n                                      tol = 1,\n                                      grid_shape = c(1,1), \n                                      max_depth = 8,\n                                      agg = 10,\n                                      sparse = TRUE,\n                                      verbose = FALSE)\n    road_samples_cc$density <- road_network_cc_densities * 1000\n    road_lixels_cc$density <- road_network_cc_densities * 1000\n    \n    tmap_options(\"view\")\n          tm_shape(localities) +\n        tm_polygons(\"LOC_NAME\", alpha=0.1) +\n        tm_shape(boundary) +\n        tm_borders(lwd = 2.5, lty = 5,  col=\"blue\") +\n        tm_shape(road_lixels_cc) +\n        tm_lines(lwd = 1.5, col = \"density\")+\n        tm_shape(loc_interest)+ \n        tm_dots(size = 0.03, alpha = 0.6)"
  }
]